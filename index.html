<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>컬러 체인</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800;900&family=Black+Han+Sans&display=swap');
@font-face {
  font-family: 'LilitaOne';
  src: url('assets/fonts/LilitaOne-Regular.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}
:root {
  --color-bg: #daedf8;
  --color-panel: rgba(255,255,255,.68);
  --color-border: rgba(160,205,230,.45);
  --color-accent: #4db8d9;
  --color-text: #3a5068;
  --color-muted: #7a9ab5;
  --font-ui: 'Outfit', sans-serif;
  --font-title: 'LilitaOne', 'Outfit', sans-serif;
}
*{margin:0;padding:0;box-sizing:border-box}
body{
  background: var(--color-bg);
  color:var(--color-text);font-family:var(--font-ui);
  display:flex;justify-content:center;align-items:center;
  min-height:100vh;padding:0;
  overflow:hidden;
}
#bg-video{position:fixed;top:0;left:0;width:100vw;height:100vh;object-fit:contain;z-index:-1;pointer-events:none;opacity:.55}
#bg-drops-canvas{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0;pointer-events:none}
#game-container{position:relative;z-index:1;display:flex;flex-direction:column;align-items:center;gap:8px;transform-origin:center center}
#top-bar{display:flex;justify-content:space-between;align-items:center;width:100%;padding:0 4px}
#score-display{font-size:17px;font-weight:800;color:var(--color-text)}
#score-display .hud-label{font-size:11px;letter-spacing:1.5px;color:var(--color-muted);text-transform:uppercase;display:block}
#score-display #score{color:#d08820;font-size:22px;font-family:var(--font-title);text-shadow:0 1px 4px rgba(180,120,40,.2)}
#combo-display{font-size:14px;font-weight:800;color:transparent;min-width:100px;text-align:right;transition:transform .15s,text-shadow .2s}
#combo-display.active{background:linear-gradient(180deg,#fde68a 0%,#fbbf24 45%,#d97706 100%);-webkit-background-clip:text;background-clip:text;color:transparent;text-shadow:0 0 12px rgba(251,191,36,.5),0 0 24px rgba(251,191,36,.25),0 1px 2px rgba(120,53,15,.3);animation:combo-glow-pulse .8s ease-in-out}
@keyframes combo-glow-pulse{0%{transform:scale(1);filter:brightness(1)}30%{transform:scale(1.15);filter:brightness(1.3)}60%{transform:scale(0.97);filter:brightness(1.1)}100%{transform:scale(1);filter:brightness(1)}}
#turn-display{font-size:13px;font-weight:600;color:var(--color-muted);text-align:right}
#turn-display .hud-label{font-size:11px;letter-spacing:1.5px;color:var(--color-muted);text-transform:uppercase;display:block}
#turn-display #turn{color:#3ba5c5;font-size:16px;font-family:var(--font-title)}
#session-bar{display:flex;justify-content:space-between;align-items:center;width:100%;padding:0 4px;gap:8px;flex-wrap:wrap}
#mode-pill{font-size:10px;font-weight:700;letter-spacing:1.3px;text-transform:uppercase;color:#2d8aaa;background:rgba(77,184,217,.12);border:1px solid rgba(77,184,217,.3);border-radius:999px;padding:4px 10px}
#locale-select,#fx-intensity-select{background:rgba(255,255,255,.55);color:#4a6878;border:1px solid var(--color-border);border-radius:8px;padding:4px 8px;font-family:var(--font-ui);font-size:12px}
#locale-select:focus,#fx-intensity-select:focus{outline:1px solid var(--color-accent);outline-offset:1px}
#fx-intensity-select{min-width:96px}
#match-panel{width:100%;max-width:380px;background:var(--color-panel);border:1px solid var(--color-border);border-radius:12px;padding:8px 12px;display:flex;flex-direction:column;gap:7px;box-shadow:0 4px 20px rgba(100,160,200,.15);backdrop-filter:blur(8px)}
.match-row{display:flex;align-items:center;gap:6px}
.match-row.wrap{flex-wrap:wrap}
.match-label{font-size:10px;font-weight:700;letter-spacing:1.1px;color:var(--color-muted);text-transform:uppercase;min-width:46px}
.match-input{flex:1;min-width:0;background:rgba(255,255,255,.55);color:#3a5068;border:1px solid rgba(160,205,230,.4);border-radius:8px;padding:6px 8px;font-family:var(--font-ui);font-size:12px}
.match-input:focus{outline:1px solid var(--color-accent);outline-offset:1px}
.match-btn{background:rgba(255,255,255,.45);color:#5a7a90;border:1px solid rgba(160,205,230,.4);border-radius:8px;padding:6px 10px;font-family:var(--font-ui);font-size:11px;font-weight:700;letter-spacing:.6px;cursor:pointer;transition:background .15s,border-color .15s}
.match-btn:hover{background:rgba(255,255,255,.65);border-color:rgba(77,184,217,.5)}
.match-btn:disabled{opacity:.4;cursor:not-allowed}
.match-btn.primary{background:rgba(77,184,217,.18);border-color:rgba(77,184,217,.45);color:#2d7a9a}
.match-btn.primary:hover{background:rgba(77,184,217,.28)}
.match-btn.warn{background:rgba(220,160,50,.1);border-color:rgba(220,160,50,.35);color:#b87a20}
.match-meta{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;align-items:center}
.match-meta-key{font-size:10px;color:var(--color-muted);font-weight:700;letter-spacing:1px;text-transform:uppercase}
.match-meta-val{font-size:12px;color:#5a7a90;min-height:16px}
.match-meta-val.strong{color:#2a4a5a}
.match-meta-val.ok{color:#2a9a6a}
.match-meta-val.warn{color:#b87a20}
.match-meta-val.bad{color:#d04050}
/* Boards row */
#boards-row{display:flex;flex-direction:column;align-items:center;gap:0;position:relative}
#boards-row.versus{flex-direction:row;align-items:flex-start;gap:16px}
/* Board wrapper */
#board-wrapper{position:relative;border:2px solid rgba(160,210,235,.5);border-radius:10px;overflow:visible;background:transparent;width:216px;height:437px;box-shadow:0 2px 16px rgba(100,170,210,.18)}
#board-bg{position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(180,215,240,.55);border-radius:8px;z-index:1;overflow:hidden;backdrop-filter:blur(4px)}
canvas#gameCanvas{display:block;margin:calc(-1 * var(--fx-pad, 60px));position:relative;z-index:10;pointer-events:none}
canvas#comboBannerCanvas{position:absolute;top:calc(4px - var(--fx-pad, 60px));left:calc(-1 * var(--fx-pad, 60px));z-index:40;pointer-events:none}
#heat-bar{width:100%;height:4px;background:rgba(160,205,230,.3);overflow:hidden;position:relative;z-index:2}
#heat-bar-fill{height:100%;border-radius:0 2px 2px 0;transition:width .3s;background:linear-gradient(90deg,#6bc5e0,#4db8d9);box-shadow:0 0 6px rgba(77,184,217,.3)}
/* Side panels (right) */
#side-panels{position:absolute;top:0;right:-76px;display:flex;flex-direction:column;gap:12px;z-index:20}
#boards-row.versus #side-panels{display:none}
.side-box{display:flex;flex-direction:column;align-items:center;gap:3px}
.side-label{font-size:9px;font-weight:700;color:var(--color-muted);text-transform:uppercase;letter-spacing:1.5px}
.side-canvas{background:rgba(180,215,240,.45);border:1px solid rgba(160,210,235,.4);border-radius:6px}
/* Junk preview (left) */
#junk-preview{position:absolute;top:0;left:-72px;width:62px;display:flex;flex-direction:column;align-items:center;gap:4px;z-index:20}
#junk-count-badge{background:rgba(255,255,255,.5);border:1.5px solid rgba(160,205,230,.4);border-radius:8px;color:var(--color-muted);font-size:22px;font-family:var(--font-title);width:52px;height:36px;display:flex;align-items:center;justify-content:center;transition:color .2s,border-color .2s,box-shadow .2s}
#junk-count-badge.warn{color:#b87a20;border-color:rgba(220,160,50,.5)}
#junk-count-badge.danger{color:#d04050;border-color:rgba(210,60,80,.5);box-shadow:0 0 8px rgba(210,60,80,.2)}
#junk-col-bar{display:flex;flex-direction:column;gap:2px;width:52px}
.junk-col-dot{width:100%;height:7px;border-radius:3px;background:rgba(255,255,255,.4);border:1px solid rgba(160,205,230,.3);transition:background .2s,box-shadow .2s}
.junk-col-dot.active{background:rgba(210,80,90,.25);border-color:rgba(210,80,90,.45)}
.junk-col-dot.multi{background:rgba(210,80,90,.5);border-color:#d04050;box-shadow:0 0 4px rgba(210,60,80,.25)}
/* Board flash */
@keyframes flash-in {
  0%   { box-shadow: 0 0 0 3px rgba(77,184,217,.5), 0 2px 16px rgba(100,170,210,.18); }
  45%  { box-shadow: 0 0 0 5px rgba(77,184,217,.6), 0 0 20px 8px rgba(77,184,217,.2); }
  100% { box-shadow: 0 2px 16px rgba(100,170,210,.18); }
}
@keyframes flash-out {
  0%   { box-shadow: 0 0 0 4px rgba(100,200,230,.5), 0 0 24px 6px rgba(100,200,230,.18); }
  100% { box-shadow: 0 2px 16px rgba(100,170,210,.18); }
}
#board-wrapper.flash-in  { animation: flash-in  0.55s ease-out forwards; }
#board-wrapper.flash-out { animation: flash-out 0.45s ease-out forwards; }
/* Game-over overlay */
#game-over-overlay{display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(210,230,245,.88);z-index:200;flex-direction:column;justify-content:center;align-items:center;gap:14px;border-radius:8px;backdrop-filter:blur(6px)}
#game-over-overlay.show{display:flex}
#game-over-overlay h2{font-family:var(--font-title);font-size:30px;font-weight:normal;text-transform:uppercase;letter-spacing:3px}
#game-over-overlay.result-gameover h2{color:#d04050;text-shadow:0 1px 8px rgba(210,60,80,.3)}
#game-over-overlay.result-win h2{color:#d08820;text-shadow:0 1px 12px rgba(200,140,30,.35)}
#game-over-overlay.result-lose h2{color:#7a9ab5;text-shadow:none}
#game-over-overlay.result-draw h2{color:#5a7a90;text-shadow:0 1px 8px rgba(90,120,140,.2)}
#game-over-overlay .final-score{font-size:15px;color:#7a9ab5}
#game-over-overlay .final-score #final-score{color:#d08820;font-weight:800;font-size:22px;font-family:var(--font-title)}
#restart-btn{margin-top:4px;padding:10px 32px;background:rgba(77,184,217,.2);color:#2d7a9a;border:1px solid rgba(77,184,217,.45);border-radius:8px;font-family:var(--font-ui);font-size:14px;font-weight:700;cursor:pointer;letter-spacing:1px;transition:background .15s}
#restart-btn:hover{background:rgba(77,184,217,.32)}
#restart-btn:disabled{opacity:.4;cursor:not-allowed}
#rematch-btn{padding:8px 24px;background:rgba(42,154,106,.12);color:#2a7a5a;border:1px solid rgba(42,154,106,.35);border-radius:8px;font-family:var(--font-ui);font-size:12px;font-weight:700;cursor:pointer;letter-spacing:1px;transition:background .15s}
#rematch-btn:hover{background:rgba(42,154,106,.2)}
/* VS separator */
#vs-sep{display:none;font-family:var(--font-title);font-size:22px;color:rgba(77,184,217,.4);writing-mode:vertical-rl;letter-spacing:6px;align-self:center;text-transform:uppercase}
#boards-row.versus #vs-sep{display:block}
/* Opponent panel */
#opponent-panel{display:none;flex-direction:column;align-items:center;gap:6px}
#boards-row.versus #opponent-panel{display:flex}
#opp-header{font-size:11px;color:var(--color-muted);text-align:center;letter-spacing:1px;min-height:16px}
#opp-board-wrapper{position:relative;border:2px solid rgba(160,210,235,.5);border-radius:10px;overflow:hidden;background:rgba(180,215,240,.55);width:216px;height:432px;box-shadow:0 2px 16px rgba(100,170,210,.18)}
#opp-canvas{display:block}
#opp-overlay{display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(210,230,245,.82);z-index:10;flex-direction:column;justify-content:center;align-items:center;gap:6px;border-radius:8px}
#opp-overlay.show{display:flex}
#opp-overlay-text{font-family:var(--font-title);font-size:18px;color:#7a9ab5;letter-spacing:2px;text-transform:uppercase}
#opp-score{font-size:11px;color:var(--color-muted);text-align:center}
/* Controls */
#controls-hint{font-size:10px;color:var(--color-muted);text-align:center;line-height:1.8}
#touch-controls{display:none;width:100%;gap:6px;justify-content:center;padding-top:4px;flex-wrap:wrap}
.touch-btn{width:52px;height:52px;background:rgba(255,255,255,.5);border:1px solid rgba(160,205,230,.4);border-radius:10px;color:#5a7a90;font-size:18px;display:flex;align-items:center;justify-content:center;cursor:pointer;-webkit-tap-highlight-color:transparent;user-select:none}
.touch-btn:active{background:rgba(77,184,217,.18)}
.touch-btn.wide{width:64px;font-size:11px;font-weight:700;letter-spacing:1px}
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
@media(pointer:coarse){#touch-controls{display:flex}#controls-hint{display:none}}
/* Conn dot */
.conn-dot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
.conn-dot.offline{background:#aab8c8}
.conn-dot.connecting{background:#d0a030;animation:pulse-dot 0.8s infinite}
.conn-dot.connected{background:#2a9a6a}
.conn-dot.in-match{background:#4db8d9}
@keyframes pulse-dot{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.6;transform:scale(.85)}}
/* Match advanced section */
#match-advanced{margin-top:2px}
#match-advanced summary{font-size:10px;color:var(--color-muted);cursor:pointer;list-style:none;padding:2px 0;font-weight:700;letter-spacing:1px;text-transform:uppercase;user-select:none}
#match-advanced summary::-webkit-details-marker{display:none}
/* Cross-board attack canvas */
#cross-canvas{position:absolute;top:0;left:0;pointer-events:none;display:none;z-index:100}
/* Opponent attack badge */
#opp-atk-badge{font-size:13px;font-weight:800;color:#d08820;text-shadow:0 1px 6px rgba(200,140,30,.3);opacity:0;transition:opacity .2s;font-family:var(--font-title);pointer-events:none;min-height:18px;text-align:center}
#opp-atk-badge.visible{opacity:1}
/* Blink animation for opp overlay waiting state */
@keyframes blink-dots{0%,100%{opacity:1}50%{opacity:.3}}
#opp-overlay-text{animation:blink-dots 1.2s infinite}
#opp-overlay-text.no-blink{animation:none}
/* Score pop */
@keyframes score-pop{0%{transform:scale(1)}35%{transform:scale(1.45)}70%{transform:scale(0.95)}100%{transform:scale(1)}}
#score{display:inline-block}
#score.pop{animation:score-pop 0.28s cubic-bezier(.36,.07,.19,.97)}
/* Combo display enhancement */
#combo-display{transition:color 0.15s,text-shadow 0.2s}
/* Chain floater glow via text-shadow is done in canvas */
/* FX Settings Panel */
#fx-settings-btn{background:rgba(255,255,255,.45);border:1px solid rgba(160,205,230,.35);border-radius:7px;padding:3px 9px;font-family:var(--font-ui);font-size:11px;font-weight:600;color:#5a8098;cursor:pointer;letter-spacing:.5px}
#fx-settings-btn:hover{background:rgba(255,255,255,.6)}
#fx-settings-panel{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(240,248,255,.96);border:1px solid rgba(140,200,230,.35);border-radius:14px;padding:18px 22px;z-index:9999;box-shadow:0 8px 32px rgba(0,40,80,.18);min-width:260px;max-width:320px;font-family:var(--font-ui)}
#fx-settings-panel.open{display:block}
.fx-panel-title{font-size:14px;font-weight:800;color:#3a6a85;margin-bottom:12px;letter-spacing:.5px}
.fx-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
.fx-row label{font-size:11px;font-weight:600;color:#5a7a90;min-width:80px}
.fx-row input[type=range]{flex:1;margin:0 8px;accent-color:#4db8d9}
.fx-row .fx-val{font-size:10px;color:#7a9ab5;min-width:28px;text-align:right;font-weight:700}
.fx-row-check{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.fx-row-check input{accent-color:#4db8d9}
.fx-row-check label{font-size:11px;font-weight:600;color:#5a7a90}
.fx-panel-close{display:block;margin:10px auto 0;background:rgba(77,184,217,.15);border:1px solid rgba(77,184,217,.3);border-radius:7px;padding:5px 20px;font-family:var(--font-ui);font-size:11px;font-weight:700;color:#3a7a95;cursor:pointer}
.fx-panel-close:hover{background:rgba(77,184,217,.25)}
/* Mute button */
#mute-btn{background:rgba(255,255,255,.45);border:1px solid rgba(160,205,230,.35);border-radius:7px;padding:3px 9px;font-family:var(--font-ui);font-size:13px;font-weight:600;color:#5a8098;cursor:pointer;letter-spacing:.5px;min-width:32px;text-align:center}
#mute-btn:hover{background:rgba(255,255,255,.6)}
#mute-btn.muted{color:#b87a20;border-color:rgba(220,160,50,.4)}
/* Pause overlay */
#pause-overlay{display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(210,230,245,.92);z-index:200;flex-direction:column;justify-content:center;align-items:center;gap:14px;border-radius:8px;backdrop-filter:blur(8px)}
#pause-overlay.show{display:flex}
#pause-overlay h2{font-family:var(--font-title);font-size:28px;color:#3a6a85;letter-spacing:3px;text-transform:uppercase}
#resume-btn{padding:10px 32px;background:rgba(77,184,217,.2);color:#2d7a9a;border:1px solid rgba(77,184,217,.45);border-radius:8px;font-family:var(--font-ui);font-size:14px;font-weight:700;cursor:pointer;letter-spacing:1px}
#resume-btn:hover{background:rgba(77,184,217,.32)}
/* Tap-move overlay */
#tap-move-overlay{display:none;position:absolute;top:0;left:0;right:0;bottom:0;z-index:15}
@media(pointer:coarse){#tap-move-overlay{display:block}}
/* Match panel collapse */
#match-panel.collapsed{display:none}
/* VS toggle button */
#vs-toggle-btn{background:rgba(77,184,217,.15);border:1px solid rgba(77,184,217,.35);border-radius:7px;padding:3px 9px;font-family:var(--font-ui);font-size:10px;font-weight:700;color:#2d7a9a;cursor:pointer;letter-spacing:1px;text-transform:uppercase}
#vs-toggle-btn:hover{background:rgba(77,184,217,.25)}
/* Countdown overlay */
#countdown-overlay{display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(210,230,245,.92);z-index:250;flex-direction:column;justify-content:center;align-items:center;border-radius:8px;backdrop-filter:blur(6px)}
#countdown-overlay.show{display:flex}
#countdown-number{font-family:var(--font-title);font-size:72px;color:#4db8d9;text-shadow:0 2px 12px rgba(77,184,217,.4);animation:countdown-pop 0.9s ease-out}
@keyframes countdown-pop{0%{transform:scale(2);opacity:0}30%{transform:scale(0.9);opacity:1}50%{transform:scale(1.1)}100%{transform:scale(1);opacity:1}}
</style>
</head>
<body>
<video id="bg-video" autoplay loop muted playsinline src="assets/img/bg-loop.mp4"></video>
<canvas id="bg-drops-canvas"></canvas>
<div id="game-container">
  <div id="top-bar">
    <div id="score-display"><span class="hud-label" data-i18n="hud.score">SCORE</span> <span id="score">0</span></div>
    <div id="combo-display"></div>
    <div id="turn-display"><span class="hud-label" data-i18n="hud.turn">TURN</span> <span id="turn">0</span></div>
  </div>
  <div id="session-bar">
    <div id="mode-pill" data-i18n="mode.solo">SOLO</div>
    <label for="fx-intensity-select" class="sr-only">FX Intensity</label>
    <select id="fx-intensity-select" aria-label="FX Intensity">
      <option value="boost">FX BOOST</option>
      <option value="normal">FX NORMAL</option>
      <option value="safe">FX SAFE</option>
    </select>
    <label for="locale-select" class="sr-only" data-i18n="ui.language">Language</label>
    <select id="locale-select" aria-label="Language">
      <option value="en">English</option>
      <option value="ko">한국어</option>
      <option value="ja">日本語</option>
      <option value="es">Español</option>
    </select>
    <button id="mute-btn" type="button" aria-label="Mute">♪</button>
    <button id="vs-toggle-btn" type="button" data-i18n="action.versus">VS MATCH</button>
    <button id="fx-settings-btn" type="button">⚙ FX</button>
  </div>
  <div id="fx-settings-panel">
    <div class="fx-panel-title">Post-Processing</div>
    <div class="fx-row-check">
      <input type="checkbox" id="pp-enabled" checked>
      <label for="pp-enabled">Enable Post-Processing</label>
    </div>
    <div class="fx-row"><label>Contrast</label><input type="range" id="pp-contrast" min="50" max="200" value="114"><span class="fx-val" id="pp-contrast-val">1.14</span></div>
    <div class="fx-row"><label>Saturation</label><input type="range" id="pp-sat" min="50" max="250" value="128"><span class="fx-val" id="pp-sat-val">1.28</span></div>
    <div class="fx-row"><label>Brightness</label><input type="range" id="pp-bright" min="50" max="150" value="102"><span class="fx-val" id="pp-bright-val">1.02</span></div>
    <div class="fx-row"><label>Hue Rotate</label><input type="range" id="pp-hue" min="-30" max="30" value="-5"><span class="fx-val" id="pp-hue-val">-5°</span></div>
    <div class="fx-row"><label>Vignette</label><input type="range" id="pp-vig" min="0" max="80" value="6"><span class="fx-val" id="pp-vig-val">0.06</span></div>
    <div class="fx-panel-title" style="margin-top:10px">Audio</div>
    <div class="fx-row"><label>Volume</label><input type="range" id="vol-slider" min="0" max="100" value="100"><span class="fx-val" id="vol-slider-val">100%</span></div>
    <button class="fx-panel-close" id="pp-close">Close</button>
  </div>
  <div id="match-panel">
    <div class="match-row">
      <div id="match-conn-dot" class="conn-dot offline"></div>
      <input id="match-player-name" class="match-input" type="text" value="" placeholder="Your name" maxlength="20">
      <button id="match-action-btn" class="match-btn primary" type="button">FIND MATCH</button>
      <button id="match-leave-btn" class="match-btn warn" type="button" style="display:none">LEAVE</button>
    </div>
    <div class="match-meta">
      <div class="match-meta-key" data-i18n="net.status">Status</div>
      <div id="match-status" class="match-meta-val">Offline</div>
      <div class="match-meta-key" data-i18n="net.opponent">Opponent</div>
      <div id="match-opponent" class="match-meta-val">-</div>
      <div class="match-meta-key" data-i18n="net.result">Result</div>
      <div id="match-result" class="match-meta-val">-</div>
    </div>
    <details id="match-advanced">
      <summary>▾ Server</summary>
      <div class="match-row" style="margin-top:6px">
        <div class="match-label" data-i18n="net.server">Server</div>
        <input id="match-server-url" class="match-input" type="text" value="" placeholder="ws://localhost:8787" spellcheck="false">
      </div>
    </details>
  </div>
  <div id="boards-row">
    <div id="board-wrapper">
      <div id="board-bg"></div>
      <div id="heat-bar"><div id="heat-bar-fill" style="width:0%"></div></div>
      <canvas id="gameCanvas"></canvas>
      <canvas id="comboBannerCanvas"></canvas>
      <div id="side-panels">
        <div class="side-box"><div class="side-label" data-i18n="panel.next">Next</div><canvas id="next-canvas" class="side-canvas" width="60" height="60"></canvas></div>
        <div class="side-box"><div class="side-label" data-i18n="panel.hold">Hold</div><canvas id="hold-canvas" class="side-canvas" width="60" height="60"></canvas></div>
      </div>
      <div id="junk-preview">
        <div class="side-label" data-i18n="panel.incoming">INCOMING</div>
        <div id="junk-count-badge">0</div>
        <div id="junk-col-bar"></div>
      </div>
      <div id="tap-move-overlay"></div>
      <div id="game-over-overlay">
        <h2 data-i18n="overlay.gameOver">Game Over</h2>
        <div class="final-score"><span data-i18n="hud.score">SCORE</span> <span id="final-score">0</span></div>
        <button id="restart-btn" data-i18n="action.retry">RETRY</button>
        <button id="rematch-btn" data-i18n="net.rematch" style="display:none">FIND MATCH AGAIN</button>
      </div>
      <div id="pause-overlay">
        <h2 data-i18n="overlay.paused">PAUSED</h2>
        <button id="resume-btn" data-i18n="action.resume">RESUME</button>
      </div>
      <div id="countdown-overlay">
        <div id="countdown-number"></div>
      </div>
    </div>
    <div id="vs-sep">VS</div>
    <div id="opponent-panel">
      <div id="opp-header"></div>
      <div id="opp-atk-badge"></div>
      <div id="opp-board-wrapper">
        <canvas id="opp-canvas" width="216" height="432"></canvas>
        <div id="opp-overlay"><div id="opp-overlay-text">WAITING...</div></div>
      </div>
      <div id="opp-score"></div>
    </div>
    <canvas id="cross-canvas"></canvas>
  </div>
  <div id="controls-hint" data-i18n="controls.hint">← → Move | Z/X Rotate | ↓ Soft Drop | Space Hard Drop | C Hold</div>
  <div id="touch-controls">
    <div class="touch-btn" data-action="left" aria-label="Move Left">◀</div>
    <div class="touch-btn" data-action="rotL" aria-label="Rotate Left">↺</div>
    <div class="touch-btn" data-action="down" aria-label="Soft Drop">▼</div>
    <div class="touch-btn" data-action="rotR" aria-label="Rotate Right">↻</div>
    <div class="touch-btn" data-action="right" aria-label="Move Right">▶</div>
    <div class="touch-btn wide" data-action="drop" data-i18n="action.drop">DROP</div>
    <div class="touch-btn wide" data-action="hold" data-i18n="action.hold">HOLD</div>
  </div>
</div>
<script>
// ═══ CONSTANTS ═══
const COLS = 6, ROWS = 12, CELL = 36, PAD = 96;
const BOARD_W = COLS * CELL, BOARD_H = ROWS * CELL;
const COLORS = [null, '#7ec8f0', '#88dda6', '#f0a8c4', '#c8a8f0', '#f0d080'];
const COLOR_RGB = [null, [126,200,240], [136,221,166], [240,168,196], [200,168,240], [240,208,128]];
const MAX_LEVEL = 5, JUNK = -1;
const JUNK_COLOR = '#8a9ab0', JUNK_RGB = [138, 154, 176];
// Chain-based water palettes: gentle ripples → tsunami as combo rises
const WATER_CHAIN_PALETTES = [
  // chain 1: pale blue, white ripples
  [[160, 210, 255], [180, 230, 255], [200, 240, 255], [220, 245, 255], [240, 250, 255], [255, 255, 255]],
  // chain 2: bright cyan, turquoise
  [[34, 211, 238], [80, 230, 240], [103, 232, 249], [140, 240, 255], [165, 243, 252], [200, 250, 255]],
  // chain 3: teal, emerald, seafoam
  [[20, 184, 166], [52, 211, 153], [94, 234, 212], [110, 231, 183], [153, 246, 228], [180, 255, 240]],
  // chain 4: warm turquoise + amber accents
  [[34, 211, 238], [6, 182, 212], [251, 191, 36], [103, 232, 249], [253, 224, 71], [165, 243, 252]],
  // chain 5+: deep indigo + electric cyan + white foam (tsunami)
  [[99, 102, 241], [34, 211, 238], [255, 255, 255], [59, 130, 246], [103, 232, 249], [165, 180, 252]],
];
// Premium combo text palettes per chain level
var COMBO_PALETTES = {
  2: { top:'#7dd3fc', mid:'#38bdf8', bot:'#0284c7', glow:[56,189,248], stroke:'#075985' },
  3: { top:'#6ee7b7', mid:'#34d399', bot:'#059669', glow:[52,211,153], stroke:'#064e3b' },
  4: { top:'#fde68a', mid:'#fbbf24', bot:'#d97706', glow:[251,191,36], stroke:'#78350f' },
  5: { top:'#c4b5fd', mid:'#8b5cf6', bot:'#6d28d9', glow:[139,92,246], stroke:'#3b0764' }
};
var comboAura = { active: false, x: 0, y: 0, life: 0, chain: 0, startTime: 0 };
const HEAT_INTERVAL = 10, JUNK_START = 5, JUNK_BASE_INT = 3;
const DROP_INTERVAL_START = 800, DROP_INTERVAL_MIN = 220;
const RESOLVE_DELAY = 350, HEAT_DURATION = 700;
const DIRS = [[-1,0],[1,0],[0,-1],[0,1]];

// Shape templates
const SHAPES = [
  { cells: [[0,0]],             id: 'O1' },
  { cells: [[0,0],[0,1]],       id: 'I2' },
  { cells: [[0,0],[0,1],[0,2]], id: 'I3' },
  { cells: [[0,0],[1,0],[1,1]], id: 'L3' },
];
const SHAPE_WEIGHTS = [20, 25, 30, 25];
const SHAPE_WEIGHT_SUM = SHAPE_WEIGHTS.reduce((a, b) => a + b, 0);

// ═══ CANVAS ═══
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = BOARD_W + PAD * 2;
canvas.height = BOARD_H + PAD * 2;
try { document.documentElement.style.setProperty('--fx-pad', PAD + 'px'); } catch (_) {}
const comboBannerCanvasEl = document.getElementById('comboBannerCanvas');
const comboBannerCtx = comboBannerCanvasEl ? comboBannerCanvasEl.getContext('2d') : null;
if (comboBannerCanvasEl) { comboBannerCanvasEl.width = canvas.width; comboBannerCanvasEl.height = canvas.height; }
const nextCtx = document.getElementById('next-canvas').getContext('2d');
const holdCtx = document.getElementById('hold-canvas').getContext('2d');
var wdOffCanvas = document.createElement('canvas');
wdOffCanvas.width = BOARD_W; wdOffCanvas.height = BOARD_H;
var wdOffCtx = wdOffCanvas.getContext('2d');
const oppCanvasEl = document.getElementById('opp-canvas');
const oppCtx = oppCanvasEl ? oppCanvasEl.getContext('2d') : null;

// ═══ STATE ═══
let board, score, turn, currentPiece, nextPiece, holdPiece, holdUsedThisTurn, gameOver;
let dropTimer, dropInterval = 800, lastFrameTime;
let frameNowMs = 0;
let gameState = 'playing', resolveTimer = 0;
let heatAnimTimer = 0, preHeatBoard = null;
let comboCount = 0, hitstopTimer = 0;
let lastCoinsMilestone = 0;
let paused = false;
let countdownActive = false;
let masterVolume = 1, muted = false;
let activeCells = new Set();
let pendingJunkCols = [], warningJunkCols = [];
let particles = [], floatingTexts = [], comboBannerTexts = [], rings = [], impactBursts = [];
// ═══ WATER SPLASH — condensation burst effect ═══
var splashDrops = [], splashDiscs = [], splashRings = [];
var SPLASH_MAX = { drops: 120, discs: 12, rings: 15 };
function splashPush(arr, obj, mx) { if (arr.length < mx) arr.push(obj); }
function splashMkDrop(x, y, vx, vy, r, cr, cg, cb, lr, lg, lb) {
  return { x:x, y:y, vx:vx, vy:vy, r:r, life:1, decay:0.012+Math.random()*0.008,
    wob:Math.random()*6.28, ws:0.04+Math.random()*0.04,
    cr:cr, cg:cg, cb:cb, lr:lr, lg:lg, lb:lb };
}
function splashMkDisc(x, y, pw, lr, lg, lb) {
  return { x:x, y:y, r:6+pw*3, maxR:40+pw*18, spd:3+pw*1.5, life:1,
    decay:0.025+0.004/Math.max(pw,1), lr:lr, lg:lg, lb:lb };
}
function splashMkRing(x, y, lr, lg, lb, mR) {
  return { x:x, y:y, r:1, mR:mR||35, sp:1.2, life:1, lr:lr, lg:lg, lb:lb };
}
function splashSpawn(cx, cy, pw, colorIdx) {
  pw = Math.min(pw, 3);
  // Ocean water color — matches background sea, tinted by cell color
  var cr = 100, cg = 195, cb = 210;
  var lr = 170, lg = 230, lb = 240;
  if (colorIdx > 0 && COLOR_RGB[colorIdx]) {
    var tr = COLOR_RGB[colorIdx][0], tg = COLOR_RGB[colorIdx][1], tb = COLOR_RGB[colorIdx][2];
    cr = Math.round(cr * 0.6 + tr * 0.4); cg = Math.round(cg * 0.6 + tg * 0.4); cb = Math.round(cb * 0.6 + tb * 0.4);
    lr = Math.round(Math.min(255, lr * 0.6 + (tr + 70) * 0.4)); lg = Math.round(Math.min(255, lg * 0.6 + (tg + 70) * 0.4)); lb = Math.round(Math.min(255, lb * 0.6 + (tb + 70) * 0.4));
  }
  // Disc
  splashPush(splashDiscs, splashMkDisc(cx,cy,pw,lr,lg,lb), SPLASH_MAX.discs);
  // Crown drops — large, visible
  var armN = getFxCount(8 + Math.floor(pw*2));
  var T2 = Math.PI*2;
  for (var i = 0; i < armN; i++) {
    var a = (T2/armN)*i + (Math.random()-0.5)*0.5;
    var sp = 2.5 + Math.random()*3.5 + pw*0.8;
    var dr = 10 + Math.random()*12 + pw*2;
    splashPush(splashDrops, splashMkDrop(cx,cy,Math.cos(a)*sp,Math.sin(a)*sp-1.5,dr,cr,cg,cb,lr,lg,lb), SPLASH_MAX.drops);
  }
  // Upward drops
  var upN = getFxCount(3 + Math.floor(pw*1.5));
  for (var i = 0; i < upN; i++) {
    var a = -Math.PI/2 + (Math.random()-0.5)*1.2;
    var sp = 2.5 + Math.random()*3 + pw*0.8;
    splashPush(splashDrops, splashMkDrop(cx,cy,Math.cos(a)*sp*0.4,Math.sin(a)*sp,12+Math.random()*8+pw*2,cr,cg,cb,lr,lg,lb), SPLASH_MAX.drops);
  }
  // Ring — bigger
  splashPush(splashRings, splashMkRing(cx,cy,lr,lg,lb,35+pw*12), SPLASH_MAX.rings);
}
function splashTick() {
  var G=0.12, DR=0.994;
  for (var i=splashDiscs.length-1;i>=0;i--) {
    var d=splashDiscs[i]; d.r+=d.spd; d.spd*=0.95; d.life-=d.decay;
    if (d.life<=0||d.r>=d.maxR) splashDiscs.splice(i,1);
  }
  for (var i=splashDrops.length-1;i>=0;i--) {
    var d=splashDrops[i]; d.vy+=G; d.vx*=DR; d.vy*=DR;
    d.x+=d.vx; d.y+=d.vy; d.life-=d.decay; d.wob+=d.ws;
    if (d.y>BOARD_H+10) d.life=0;
    if (d.x<-20||d.x>BOARD_W+20) d.life=0;
    if (d.life<=0||d.r*Math.max(0.3,d.life)<0.3) splashDrops.splice(i,1);
  }
  for (var i=splashRings.length-1;i>=0;i--) {
    var r=splashRings[i]; r.r+=r.sp; r.life-=0.015;
    if (r.life<=0||r.r>r.mR) splashRings.splice(i,1);
  }
}
function splashDraw(ctx) {
  var T2=Math.PI*2;
  // Discs
  for (var i=0;i<splashDiscs.length;i++) {
    var d=splashDiscs[i], a=Math.min(d.life,1);
    ctx.save(); ctx.globalAlpha=a*0.3;
    var g=ctx.createRadialGradient(d.x,d.y,d.r*0.2,d.x,d.y,d.r);
    g.addColorStop(0,'rgba(255,255,255,0.35)');
    g.addColorStop(0.5,'rgba('+d.lr+','+d.lg+','+d.lb+',0.2)');
    g.addColorStop(1,'rgba('+d.lr+','+d.lg+','+d.lb+',0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,T2); ctx.fill();
    ctx.globalAlpha=a*0.7; ctx.strokeStyle='rgba(255,255,255,'+(a*0.7)+')';
    ctx.lineWidth=Math.max(0.5,2.5*a); ctx.beginPath(); ctx.arc(d.x,d.y,d.r*0.95,0,T2); ctx.stroke();
    ctx.restore();
  }
  // Rings
  for (var i=0;i<splashRings.length;i++) {
    var r=splashRings[i], a=Math.min(r.life,1);
    ctx.save(); ctx.globalAlpha=a*0.5; ctx.strokeStyle='rgba(255,255,255,'+(a*0.6)+')';
    ctx.lineWidth=Math.max(0.4,1.8*a); ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,T2); ctx.stroke();
    ctx.restore();
  }
  // Drops with distortion
  splashDrops.sort(function(a,b){return b.r-a.r;});
  for (var i=0;i<splashDrops.length;i++) {
    var d=splashDrops[i], a=Math.min(d.life,1);
    var r=d.r*(1+Math.sin(d.wob)*0.05)*Math.max(0.4,a);
    if (r<0.4) continue;
    // Lens distortion using wdOffCanvas
    if (r>2) {
      var zm=1.25, sr=r*zm;
      ctx.save(); ctx.beginPath(); ctx.arc(d.x,d.y,r,0,T2); ctx.clip();
      ctx.globalAlpha=a;
      ctx.drawImage(wdOffCanvas, d.x-sr,d.y-sr,sr*2,sr*2, d.x-r,d.y-r,r*2,r*2);
      ctx.restore();
    }
    ctx.save(); ctx.translate(d.x,d.y);
    // Condensation tint — more visible
    ctx.globalAlpha=a*0.35;
    var bg=ctx.createRadialGradient(0,-r*0.1,r*0.05,0,0,r);
    bg.addColorStop(0,'rgba('+d.lr+','+d.lg+','+d.lb+',0.5)');
    bg.addColorStop(0.4,'rgba('+d.cr+','+d.cg+','+d.cb+',0.3)');
    bg.addColorStop(0.8,'rgba('+d.cr+','+d.cg+','+d.cb+',0.1)');
    bg.addColorStop(1,'rgba('+d.cr+','+d.cg+','+d.cb+',0)');
    ctx.fillStyle=bg; ctx.beginPath(); ctx.arc(0,0,r,0,T2); ctx.fill();
    // Caustic edge arcs — brighter
    ctx.globalAlpha=a*0.75; ctx.strokeStyle='rgba('+d.lr+','+d.lg+','+d.lb+',0.8)';
    ctx.lineWidth=Math.max(0.3,r*0.06); ctx.beginPath(); ctx.arc(0,0,r*0.94,0.3,1.8); ctx.stroke();
    ctx.globalAlpha=a*0.55; ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.lineWidth=Math.max(0.2,r*0.035); ctx.beginPath(); ctx.arc(0,0,r*0.94,0.5,1.5); ctx.stroke();
    // Top-left rim
    ctx.globalAlpha=a*0.35; ctx.strokeStyle='rgba('+d.lr+','+d.lg+','+d.lb+',0.5)';
    ctx.lineWidth=Math.max(0.2,r*0.03); ctx.beginPath(); ctx.arc(0,0,r*0.94,3.3,4.8); ctx.stroke();
    // Environment reflection
    ctx.globalAlpha=a*0.25;
    var eg=ctx.createRadialGradient(0,-r*0.3,0,0,-r*0.2,r*0.7);
    eg.addColorStop(0,'rgba('+d.lr+','+d.lg+','+d.lb+',0.55)');
    eg.addColorStop(0.5,'rgba(200,240,255,0.2)');
    eg.addColorStop(1,'rgba(200,240,255,0)');
    ctx.fillStyle=eg; ctx.beginPath(); ctx.arc(0,-r*0.1,r*0.7,Math.PI,0); ctx.fill();
    // Sharp specular — bigger and brighter
    ctx.globalAlpha=a*0.9; ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.arc(-r*0.2,-r*0.3,Math.max(0.7,r*0.13),0,T2); ctx.fill();
    ctx.globalAlpha=a*0.3;
    ctx.beginPath(); ctx.arc(-r*0.2,-r*0.3,r*0.25,0,T2); ctx.fill();
    // Secondary specular
    if (r>3) {
      ctx.globalAlpha=a*0.5; ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(r*0.15,-r*0.4,Math.max(0.4,r*0.06),0,T2); ctx.fill();
    }
    // Bottom caustic
    ctx.globalAlpha=a*0.25;
    var cg=ctx.createRadialGradient(r*0.05,r*0.35,0,r*0.05,r*0.35,r*0.3);
    cg.addColorStop(0,'rgba(255,255,255,0.4)');
    cg.addColorStop(0.5,'rgba('+d.lr+','+d.lg+','+d.lb+',0.2)');
    cg.addColorStop(1,'rgba('+d.lr+','+d.lg+','+d.lb+',0)');
    ctx.fillStyle=cg; ctx.beginPath(); ctx.arc(r*0.05,r*0.35,r*0.3,0,T2); ctx.fill();
    ctx.restore();
  }
}
// ═══ FULL-SCREEN POST-PROCESSING (CSS filter on body) ═══
var ppSettings = {
  enabled: true,
  contrast: 1.14,
  saturate: 1.28,
  brightness: 1.02,
  hueRotate: -5,
  vignette: 0.06,
};
// Vignette overlay element
var ppVigEl = document.createElement('div');
ppVigEl.id = 'pp-vignette';
ppVigEl.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:9990;';
document.body.appendChild(ppVigEl);

function ppApply() {
  var pp = ppSettings;
  if (!pp.enabled) {
    document.body.style.filter = '';
    ppVigEl.style.background = 'none';
    return;
  }
  document.body.style.filter =
    'contrast(' + pp.contrast + ') ' +
    'saturate(' + pp.saturate + ') ' +
    'brightness(' + pp.brightness + ')' +
    (pp.hueRotate ? ' hue-rotate(' + pp.hueRotate + 'deg)' : '');
  if (pp.vignette > 0.01) {
    ppVigEl.style.background = 'radial-gradient(ellipse at center, transparent 50%, rgba(0,15,30,' + pp.vignette + ') 100%)';
  } else {
    ppVigEl.style.background = 'none';
  }
}
ppApply();
// ═══ WATER DROPLETS v5 — cold bottle condensation ═══
var wdDrops = [], wdTrails = [];
var WD = {
  SLIDE_R:4, GRAVITY:0.0025, MAX:45, MIN_R:0.5, MAX_R:5.5,
  TRAIL_DIST:8, TRAIL_SIZE:0.25, MASS_LOSS:0.06,
  EVAP:0.0002, TRAIL_FADE:0.0004, TRAIL_MAX:100
};
function wdMake(x,y,r,state){
  return {x:x,y:y,r:r,vx:0,vy:0,state:state||'static',
    seed:Math.floor(Math.random()*5)+2,age:0,
    bias:(Math.random()-0.5)*0.4,
    biasT:Math.random()*999,
    path:[],lastTrailDist:0
  };
}
function wdInit(){
  wdDrops=[]; wdTrails=[];
  // A few medium drops
  for(var i=0;i<3;i++) wdDrops.push(wdMake(
    8+Math.random()*(BOARD_W-16),10+Math.random()*(BOARD_H-20),
    2+Math.random()*2,'static'));
  // Sparse tiny condensation beads
  for(var i=0;i<20;i++) wdDrops.push(wdMake(
    2+Math.random()*(BOARD_W-4),2+Math.random()*(BOARD_H-4),
    0.5+Math.random()*1.2,'static'));
}
wdInit();
// Trail shape helpers
function wdBuildTrailPoly(path,baseW){
  var len=path.length; if(len<2) return null;
  var L=[],R=[];
  for(var i=0;i<len;i++){
    var t=i/(len-1);
    var w=baseW*(0.05+t*0.95)*0.5;
    // Slight edge irregularity
    w*=1+Math.sin(i*2.1+path[i].x*0.08)*0.12;
    var dx,dy;
    if(i===0){dx=path[1].x-path[0].x;dy=path[1].y-path[0].y;}
    else if(i===len-1){dx=path[i].x-path[i-1].x;dy=path[i].y-path[i-1].y;}
    else{dx=path[i+1].x-path[i-1].x;dy=path[i+1].y-path[i-1].y;}
    var mag=Math.sqrt(dx*dx+dy*dy)||1;
    var nx=-dy/mag, ny=dx/mag;
    L.push({x:path[i].x+nx*w,y:path[i].y+ny*w});
    R.push({x:path[i].x-nx*w,y:path[i].y-ny*w});
  }
  return {L:L,R:R};
}
function wdFillTrailPoly(ctx,s){
  if(!s) return;
  ctx.beginPath();
  ctx.moveTo(s.L[0].x,s.L[0].y);
  for(var i=1;i<s.L.length;i++) ctx.lineTo(s.L[i].x,s.L[i].y);
  for(var i=s.R.length-1;i>=0;i--) ctx.lineTo(s.R[i].x,s.R[i].y);
  ctx.closePath();
}
function wdUpdate(){
  // Condensation: occasional tiny beads appear
  if(wdDrops.length<WD.MAX&&Math.random()<0.025){
    wdDrops.push(wdMake(2+Math.random()*(BOARD_W-4),
      2+Math.random()*(BOARD_H-4), 0.5+Math.random()*0.8,'static'));
  }
  for(var i=wdDrops.length-1;i>=0;i--){
    var d=wdDrops[i]; d.age++;
    if(d.state==='static'){
      // Slow condensation growth
      d.r+=0.0003+Math.random()*0.0006;
      // Tiny drops evaporate if old
      if(d.r<2.5&&d.age>600) d.r-=WD.EVAP*1.2;
      if(d.r>=WD.SLIDE_R){
        d.state='sliding'; d.vy=0.01; d.path=[{x:d.x,y:d.y}]; d.lastTrailDist=0;
      }
    } else {
      // Very slow condensation slide: lurching rhythm
      var t=d.age*0.006+d.biasT*0.001;
      var fallPh=Math.sin(t+Math.sin(t+Math.sin(t)*0.5));
      // Mostly paused, occasional micro-lurch
      var accel=WD.GRAVITY*(1+Math.max(0,-fallPh)*3)*(0.15+d.r*0.04);
      d.vy+=accel;
      d.vy*=0.96;
      var maxV=0.15+d.r*0.04;
      if(d.vy>maxV) d.vy=maxV;
      // Very subtle lateral drift
      var w=t*0.5+Math.cos(t*0.5);
      var wobble=Math.sin(3*w)*Math.pow(Math.abs(Math.sin(w)),6)*0.2;
      d.vx+=(wobble+d.bias*0.005)*Math.max(0.02,d.vy)*0.2;
      if(Math.random()<0.003) d.bias=(Math.random()-0.5)*0.4;
      d.vx*=0.85;
      d.x+=d.vx; d.y+=d.vy;
      if(d.x<d.r){d.x=d.r;d.vx=Math.abs(d.vx)*0.2;}
      if(d.x>BOARD_W-d.r){d.x=BOARD_W-d.r;d.vx=-Math.abs(d.vx)*0.2;}
      // Record path
      var lastP=d.path.length?d.path[d.path.length-1]:d;
      var segDx=d.x-lastP.x, segDy=d.y-lastP.y;
      var segLen=Math.sqrt(segDx*segDx+segDy*segDy);
      if(segLen>1.5){ d.path.push({x:d.x,y:d.y}); d.lastTrailDist+=segLen; }
      if(d.path.length>100) d.path.shift();
      // Leave behind small satellite beads
      if(d.lastTrailDist>WD.TRAIL_DIST+Math.random()*6){
        if(wdDrops.length<WD.MAX+20){
          var td=wdMake(d.x+(Math.random()-0.5)*d.r*0.25,
            d.y-d.r*0.4, d.r*WD.TRAIL_SIZE,'static');
          td.age=300;
          wdDrops.push(td);
        }
        d.r*=(1-WD.MASS_LOSS);
        d.lastTrailDist=0;
        if(d.path.length>2 && wdTrails.length<WD.TRAIL_MAX){
          wdTrails.push({pts:d.path.slice(-12),w:d.r*0.55,alpha:0.2});
        }
      }
    }
    if(d.r<WD.MIN_R||d.y>BOARD_H+8){wdDrops.splice(i,1);continue;}
    if(d.r>WD.MAX_R) d.r=WD.MAX_R;
  }
  // Fade old trails
  for(var i=wdTrails.length-1;i>=0;i--){
    wdTrails[i].alpha-=WD.TRAIL_FADE;
    if(wdTrails[i].alpha<=0) wdTrails.splice(i,1);
  }
  // Merge overlapping
  for(var i=0;i<wdDrops.length;i++){
    var a=wdDrops[i]; if(!a) continue;
    for(var j=i+1;j<wdDrops.length;j++){
      var b=wdDrops[j]; if(!b) continue;
      var dx=a.x-b.x,dy=a.y-b.y,dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<(a.r+b.r)*0.6){
        var big=a.r>=b.r?a:b, sm=a.r>=b.r?b:a;
        big.r=Math.min(Math.sqrt(big.r*big.r+sm.r*sm.r),WD.MAX_R);
        big.x=(big.x*big.r+sm.x*sm.r)/(big.r+sm.r);
        if(sm.y>big.y) big.y=sm.y;
        var idx=wdDrops.indexOf(sm);
        if(idx>=0){wdDrops.splice(idx,1);if(idx<=i)i--;if(idx<j)j--;}
      }
    }
  }
}
// ── Draw one droplet (reusable for main + side panels) ──
function wdDrawDrop(c,x,y,r,speed,seed){
  // Tiny beads: just a bright speck
  if(r<1.3){c.save();c.globalAlpha=0.3;c.fillStyle='rgba(230,245,255,0.6)';c.beginPath();c.arc(x,y,r,0,Math.PI*2);c.fill();c.globalAlpha=0.5;c.fillStyle='rgba(255,255,255,0.7)';c.beginPath();c.arc(x-r*0.2,y-r*0.2,r*0.3,0,Math.PI*2);c.fill();c.restore();return;}
  c.save();
  // Clip to circle
  c.save();
  c.beginPath();c.arc(x,y,r,0,Math.PI*2);c.clip();
  // ── Distorted background (lens/refraction) ──
  var zoom=1.15+r*0.01; // stronger distortion for bigger drops
  var dstSz=r*2, srcSz=dstSz/zoom;
  // Offset creates visible shift = distortion
  var offX=r*0.15, offY=r*0.1;
  var sX=x-srcSz/2+offX, sY=y-srcSz/2+offY;
  if(sX<0)sX=0; if(sY<0)sY=0;
  if(sX+srcSz>BOARD_W)sX=BOARD_W-srcSz;
  if(sY+srcSz>BOARD_H)sY=BOARD_H-srcSz;
  if(srcSz>1.5) c.drawImage(wdOffCanvas,sX,sY,srcSz,srcSz,x-r,y-r,dstSz,dstSz);
  // Edge shadow (glass meniscus)
  var rim=c.createRadialGradient(x,y,r*0.5,x,y,r);
  rim.addColorStop(0,'rgba(0,0,0,0)');
  rim.addColorStop(0.7,'rgba(0,15,35,0.03)');
  rim.addColorStop(1,'rgba(0,15,35,0.16)');
  c.fillStyle=rim;c.fillRect(x-r,y-r,dstSz,dstSz);
  c.restore(); // end clip
  // Specular highlight
  if(r>2){
    c.globalAlpha=0.55;
    var hlR=r*0.3, hlX=x-r*0.24, hlY=y-r*0.28;
    var hl=c.createRadialGradient(hlX,hlY,0,hlX,hlY,hlR);
    hl.addColorStop(0,'rgba(255,255,255,0.92)');
    hl.addColorStop(0.35,'rgba(255,255,255,0.3)');
    hl.addColorStop(1,'rgba(255,255,255,0)');
    c.fillStyle=hl;c.beginPath();c.arc(hlX,hlY,hlR,0,Math.PI*2);c.fill();
  }
  // Tiny bright dot (only on bigger drops)
  if(r>3){c.globalAlpha=0.85;c.fillStyle='#fff';c.beginPath();c.arc(x-r*0.18,y-r*0.38,Math.max(0.5,r*0.06),0,Math.PI*2);c.fill();}
  // Rim outline
  c.globalAlpha=0.1+r*0.01;
  c.strokeStyle='rgba(255,255,255,0.35)';
  c.lineWidth=Math.max(0.25,r*0.03);
  c.beginPath();c.arc(x,y,r-0.2,0,Math.PI*2);c.stroke();
  c.restore();
}
let shakeAmount = 0, shakeBiasX = 0, shakeBiasY = 0, shakeRot = 0;
let screenFlash = 0, screenFlashColor = [34, 211, 238], screenFlashFocusX = PAD + BOARD_W / 2, screenFlashFocusY = PAD + BOARD_H / 2;
let boardPulse = 0, boardPulseColor = [103, 232, 249], boardPulseX = BOARD_W / 2, boardPulseY = BOARD_H / 2;
let cellFlash = {}, cellScale = {}, cellJelly = {};
let gameMode = 'solo';
let incomingAttackQueue = [];
let matchRuntime = { roomId: null, playerId: 'local', outgoingAttack: null };
let gameplaySeed = null, gameplayRngState = null;
let opponentBoard = null;
let crossProjectiles = [];
let crossCtx = null;
let pieceJellyFx = {
  bounceTime: 0,
  bounceAmp: 0,
  wobbleAmp: 0,
  wobblePhase: 0,
  kickX: 0,
  kickY: 0,
  tilt: 0,
  spawn: 0
};

let netClient = {
  ws: null,
  connected: false,
  connecting: false,
  queued: false,
  inMatch: false,
  clientId: null,
  roomId: null,
  matchSeed: null,
  playerName: '',
  serverUrl: '',
  opponent: null,
  lastResult: null,
  lastError: '',
  sentGameOverForRoomId: null,
  lastRemoteState: null,
  _manualDisconnect: false,
  _reconnectAttempts: 0,
  _reconnectTimer: null,
  statusKey: null,
  statusText: '',
  statusTone: '',
  statusVars: null,
};

const STORAGE_KEYS = {
  locale: 'colorchain.locale',
  fxProfile: 'colorchain.fxProfile',
  matchServerUrl: 'colorchain.match.serverUrl',
  matchPlayerName: 'colorchain.match.playerName',
  volume: 'colorchain.volume',
  muted: 'colorchain.muted',
};

const FX_PRESETS = {
  boost:  { motion: 1.10, flash: 1.00, particles: 0.85, hitstop: 0.85, audio: 1.00 },
  normal: { motion: 0.90, flash: 0.60, particles: 0.65, hitstop: 0.70, audio: 0.95 },
  safe:   { motion: 0.35, flash: 0.15, particles: 0.35, hitstop: 0.40, audio: 0.85 }
};
let fxProfile = 'boost';
let fxTuning = FX_PRESETS.boost;

const I18N = {
  en: {
    'meta.title': 'Color Chain',
    'hud.score': 'SCORE',
    'hud.turn': 'TURN',
    'panel.next': 'NEXT',
    'panel.hold': 'HOLD',
    'panel.incoming': 'INCOMING',
    'overlay.gameOver': 'Game Over',
    'overlay.victory': 'VICTORY!',
    'overlay.defeat': 'DEFEAT',
    'overlay.draw': 'DRAW',
    'action.retry': 'RETRY',
    'action.drop': 'DROP',
    'action.hold': 'HOLD',
    'controls.hint': '← → Move | Z/X Rotate | ↓ Soft Drop | Space Hard Drop | C Hold',
    'ui.language': 'Language',
    'mode.solo': 'SOLO',
    'mode.versus': 'VERSUS',
    'net.server': 'Server',
    'net.name': 'Name',
    'net.status': 'Status',
    'net.opponent': 'Opponent',
    'net.result': 'Result',
    'net.connect': 'CONNECT',
    'net.disconnect': 'DISCONNECT',
    'net.findMatch': 'FIND MATCH',
    'net.cancelQueue': 'CANCEL QUEUE',
    'net.leave': 'LEAVE',
    'net.rematch': 'FIND MATCH AGAIN',
    'net.offline': 'Offline',
    'net.connecting': 'Connecting...',
    'net.connected': 'Connected',
    'net.reconnecting': 'Reconnecting...',
    'net.queued': 'Queued for 1v1 matchmaking...',
    'net.matched': 'Match found',
    'net.matchEnded': 'Match ended',
    'net.waiting': 'Waiting...',
    'net.opponentLeft': 'Opponent left',
    'net.leftMatch': 'Left match',
    'net.socketClosed': 'Disconnected',
    'net.readyPrompt': 'Connect and press FIND MATCH',
    'net.needServerUrl': 'Enter a WebSocket server URL (e.g. wss://...)',
    'net.result.win': 'WIN',
    'net.result.lose': 'LOSE',
    'net.result.draw': 'DRAW',
    'aria.moveLeft': 'Move Left',
    'aria.moveRight': 'Move Right',
    'aria.rotateLeft': 'Rotate Left',
    'aria.rotateRight': 'Rotate Right',
    'aria.softDrop': 'Soft Drop',
    'fx.chain': '{chain}x CHAIN!',
    'fx.boom': 'BOOM!',
    'fx.junkWarning': '⚠ JUNK!',
    'fx.points': '+{points}',
    'fx.merge': '{count} MERGE +{points}',
    'overlay.paused': 'PAUSED',
    'action.resume': 'RESUME',
    'action.versus': 'VS MATCH',
  },
  ko: {
    'meta.title': '컬러 체인',
    'hud.score': '점수',
    'hud.turn': '턴',
    'panel.next': '다음',
    'panel.hold': '보관',
    'panel.incoming': '공격 예고',
    'overlay.gameOver': '게임 오버',
    'overlay.victory': '승리!',
    'overlay.defeat': '패배',
    'overlay.draw': '무승부',
    'action.retry': '다시 하기',
    'action.drop': '드롭',
    'action.hold': '킵',
    'controls.hint': '← → 이동 | Z/X 회전 | ↓ 소프트드롭 | Space 하드드롭 | C 킵',
    'ui.language': '언어',
    'mode.solo': '솔로',
    'mode.versus': '대전',
    'net.server': '서버',
    'net.name': '이름',
    'net.status': '상태',
    'net.opponent': '상대',
    'net.result': '결과',
    'net.connect': '연결',
    'net.disconnect': '연결 해제',
    'net.findMatch': '매칭 찾기',
    'net.cancelQueue': '취소',
    'net.leave': '나가기',
    'net.rematch': '다시 매칭',
    'net.offline': '오프라인',
    'net.connecting': '연결 중...',
    'net.connected': '연결됨',
    'net.reconnecting': '재연결 중...',
    'net.queued': '1v1 매칭 대기 중...',
    'net.matched': '매칭 성공',
    'net.matchEnded': '매치 종료',
    'net.waiting': '대기 중...',
    'net.opponentLeft': '상대방이 나갔습니다',
    'net.leftMatch': '매치에서 나감',
    'net.socketClosed': '연결 끊김',
    'net.readyPrompt': '연결 후 매칭 찾기를 누르세요',
    'net.needServerUrl': 'WebSocket 서버 주소를 입력하세요 (예: wss://...)',
    'net.result.win': '승리',
    'net.result.lose': '패배',
    'net.result.draw': '무승부',
    'aria.moveLeft': '왼쪽 이동',
    'aria.moveRight': '오른쪽 이동',
    'aria.rotateLeft': '왼쪽 회전',
    'aria.rotateRight': '오른쪽 회전',
    'aria.softDrop': '소프트드롭',
    'fx.chain': '{chain}연쇄!',
    'fx.boom': '펑!',
    'fx.junkWarning': '⚠ 방해블록!',
    'fx.points': '+{points}',
    'fx.merge': '{count}개 합성 +{points}',
    'overlay.paused': '일시정지',
    'action.resume': '계속하기',
    'action.versus': 'VS 매치',
  },
  ja: {
    'meta.title': 'カラー・チェイン',
    'hud.score': 'SCORE',
    'hud.turn': 'TURN',
    'panel.next': 'NEXT',
    'panel.hold': 'HOLD',
    'panel.incoming': 'INCOMING',
    'overlay.gameOver': 'ゲームオーバー',
    'overlay.victory': 'VICTORY!',
    'overlay.defeat': 'DEFEAT',
    'overlay.draw': '引き分け',
    'action.retry': 'RETRY',
    'action.drop': 'DROP',
    'action.hold': 'HOLD',
    'controls.hint': '← → 移動 | Z/X 回転 | ↓ ソフトドロップ | Space ハードドロップ | C ホールド',
    'ui.language': '言語',
    'mode.solo': 'SOLO',
    'mode.versus': 'VERSUS',
    'net.server': 'サーバー',
    'net.name': '名前',
    'net.status': '状態',
    'net.opponent': '相手',
    'net.result': '結果',
    'net.connect': '接続',
    'net.disconnect': '切断',
    'net.findMatch': 'マッチ検索',
    'net.cancelQueue': 'キャンセル',
    'net.leave': '退出',
    'net.rematch': '再マッチ',
    'net.offline': 'オフライン',
    'net.connecting': '接続中...',
    'net.connected': '接続済み',
    'net.reconnecting': '再接続中...',
    'net.queued': '1v1 マッチ待機中...',
    'net.matched': 'マッチ成立',
    'net.matchEnded': 'マッチ終了',
    'net.waiting': '待機中...',
    'net.opponentLeft': '相手が退出しました',
    'net.leftMatch': 'マッチを退出',
    'net.socketClosed': '接続が切れました',
    'net.readyPrompt': '接続してマッチ検索を押してください',
    'net.needServerUrl': 'WebSocketサーバーURLを入力 (例: wss://...)',
    'net.result.win': '勝利',
    'net.result.lose': '敗北',
    'net.result.draw': '引き分け',
    'aria.moveLeft': '左へ移動',
    'aria.moveRight': '右へ移動',
    'aria.rotateLeft': '左回転',
    'aria.rotateRight': '右回転',
    'aria.softDrop': 'ソフトドロップ',
    'fx.chain': '{chain}連鎖!',
    'fx.boom': 'BOOM!',
    'fx.junkWarning': '⚠ おじゃま!',
    'fx.points': '+{points}',
    'fx.merge': '{count} MERGE +{points}',
    'overlay.paused': '一時停止',
    'action.resume': '再開',
    'action.versus': 'VS マッチ',
  },
  es: {
    'meta.title': 'Color Chain',
    'hud.score': 'PUNTOS',
    'hud.turn': 'TURNO',
    'panel.next': 'SIG',
    'panel.hold': 'HOLD',
    'panel.incoming': 'ENTRANTE',
    'overlay.gameOver': 'Fin de partida',
    'overlay.victory': '¡VICTORIA!',
    'overlay.defeat': 'DERROTA',
    'overlay.draw': 'EMPATE',
    'action.retry': 'REINTENTAR',
    'action.drop': 'CAER',
    'action.hold': 'GUARDAR',
    'controls.hint': '← → Mover | Z/X Rotar | ↓ Caída suave | Space Caída dura | C Guardar',
    'ui.language': 'Idioma',
    'mode.solo': 'SOLO',
    'mode.versus': 'VERSUS',
    'net.server': 'Servidor',
    'net.name': 'Nombre',
    'net.status': 'Estado',
    'net.opponent': 'Rival',
    'net.result': 'Resultado',
    'net.connect': 'CONECTAR',
    'net.disconnect': 'DESCONECTAR',
    'net.findMatch': 'BUSCAR PARTIDA',
    'net.cancelQueue': 'CANCELAR',
    'net.leave': 'SALIR',
    'net.rematch': 'REVANCHA',
    'net.offline': 'Sin conexión',
    'net.connecting': 'Conectando...',
    'net.connected': 'Conectado',
    'net.reconnecting': 'Reconectando...',
    'net.queued': 'Buscando rival 1v1...',
    'net.matched': 'Partida encontrada',
    'net.matchEnded': 'Partida terminada',
    'net.waiting': 'Esperando...',
    'net.opponentLeft': 'El rival se fue',
    'net.leftMatch': 'Saliste de la partida',
    'net.socketClosed': 'Desconectado',
    'net.readyPrompt': 'Conéctate y pulsa BUSCAR PARTIDA',
    'net.needServerUrl': 'Introduce la URL del servidor (ej: wss://...)',
    'net.result.win': 'VICTORIA',
    'net.result.lose': 'DERROTA',
    'net.result.draw': 'EMPATE',
    'aria.moveLeft': 'Mover a la izquierda',
    'aria.moveRight': 'Mover a la derecha',
    'aria.rotateLeft': 'Rotar a la izquierda',
    'aria.rotateRight': 'Rotar a la derecha',
    'aria.softDrop': 'Caída suave',
    'fx.chain': '¡{chain}x CADENA!',
    'fx.boom': '¡BOOM!',
    'fx.junkWarning': '⚠ BASURA!',
    'fx.points': '+{points}',
    'fx.merge': '{count} MERGE +{points}',
    'overlay.paused': 'PAUSA',
    'action.resume': 'CONTINUAR',
    'action.versus': 'VS PARTIDA',
  }
};

const SUPPORTED_LOCALES = Object.keys(I18N);
let currentLocale = 'en';
let numberFormatter = new Intl.NumberFormat('en');

const colorChainEventHandlers = new Map();
function onColorChainEvent(type, handler) {
  if (!colorChainEventHandlers.has(type)) colorChainEventHandlers.set(type, new Set());
  colorChainEventHandlers.get(type).add(handler);
}
function offColorChainEvent(type, handler) {
  const set = colorChainEventHandlers.get(type);
  if (set) set.delete(handler);
}
function emitColorChainEvent(type, payload) {
  const evt = { type: type, ts: Date.now(), payload: payload || {} };
  const set = colorChainEventHandlers.get(type);
  if (set) { set.forEach(function(handler) { try { handler(evt); } catch (err) { console.error('[ColorChain:on]', err); } }); }
  window.dispatchEvent(new CustomEvent('colorchain:' + type, { detail: evt }));
}

function hashString32(input) {
  let h = 2166136261;
  for (let i = 0; i < input.length; i++) { h ^= input.charCodeAt(i); h = Math.imul(h, 16777619); }
  return h >>> 0;
}
function normalizeSeed(seed) {
  if (seed === null || seed === undefined || seed === '') return null;
  if (typeof seed === 'number' && Number.isFinite(seed)) return (Math.floor(seed) >>> 0);
  return hashString32(String(seed));
}
function setGameplaySeed(seed) { const n = normalizeSeed(seed); gameplaySeed = n; gameplayRngState = n; }
function randGame() {
  if (gameplayRngState === null) return Math.random();
  gameplayRngState = (gameplayRngState + 0x6D2B79F5) >>> 0;
  let t = gameplayRngState;
  t = Math.imul(t ^ (t >>> 15), t | 1);
  t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
}

function resolveLocale(locale) {
  if (!locale) return 'en';
  const raw = String(locale).toLowerCase();
  if (I18N[raw]) return raw;
  const short = raw.split('-')[0];
  return I18N[short] ? short : 'en';
}
function getDictValue(dict, key) { return dict ? dict[key] : undefined; }
function t(key, vars) {
  let value = getDictValue(I18N[currentLocale], key);
  if (value === undefined) value = getDictValue(I18N.en, key);
  if (value === undefined) value = key;
  if (!vars) return value;
  return value.replace(/\{(\w+)\}/g, function(_, name) { return vars[name] === undefined ? '' : String(vars[name]); });
}
function formatInt(v) { return numberFormatter.format(Math.max(0, Math.floor(v || 0))); }
function checkCoinsMilestone() {
  var milestone = Math.floor((score || 0) / 1000);
  if (milestone > lastCoinsMilestone) {
    var rate = 1.0 + Math.min(milestone - 1, 8) * 0.03;
    playSfx('coins', { rate: rate });
    lastCoinsMilestone = milestone;
  }
}
function updateScoreUI() {
  var el = document.getElementById('score');
  el.textContent = formatInt(score || 0);
  el.classList.remove('pop'); void el.offsetWidth; el.classList.add('pop');
  checkCoinsMilestone();
}
function updateTurnUI() { document.getElementById('turn').textContent = formatInt(turn || 0); }
function updateFinalScoreUI() { document.getElementById('final-score').textContent = formatInt(score || 0); }
function updateTouchAriaLabels() {
  const map = { left:'aria.moveLeft', right:'aria.moveRight', rotL:'aria.rotateLeft', rotR:'aria.rotateRight', down:'aria.softDrop' };
  document.querySelectorAll('.touch-btn[data-action]').forEach(function(btn) { const key = map[btn.dataset.action]; if (key) btn.setAttribute('aria-label', t(key)); });
  const localeSelect = document.getElementById('locale-select');
  if (localeSelect) localeSelect.setAttribute('aria-label', t('ui.language'));
}
function updateModeUI() {
  const modeEl = document.getElementById('mode-pill');
  if (!modeEl) return;
  modeEl.textContent = t(gameMode === 'versus' ? 'mode.versus' : 'mode.solo');
}
function applyLocalization() {
  document.documentElement.lang = currentLocale;
  document.title = t('meta.title');
  document.querySelectorAll('[data-i18n]').forEach(function(el) { el.textContent = t(el.dataset.i18n); });
  const sel = document.getElementById('locale-select');
  if (sel && sel.value !== currentLocale) sel.value = currentLocale;
  numberFormatter = new Intl.NumberFormat(currentLocale);
  updateScoreUI(); updateTurnUI();
  if (gameOver) updateFinalScoreUI();
  updateModeUI(); updateTouchAriaLabels();
  if (typeof updateMatchUi === 'function') updateMatchUi();
}
function setLocale(locale, silent) {
  currentLocale = resolveLocale(locale);
  try { localStorage.setItem(STORAGE_KEYS.locale, currentLocale); } catch (_) {}
  applyLocalization();
  if (!silent) emitColorChainEvent('localeChanged', { locale: currentLocale });
  return currentLocale;
}
function detectInitialLocale() {
  try { const saved = localStorage.getItem(STORAGE_KEYS.locale); if (saved) return saved; } catch (_) {}
  return (navigator.languages && navigator.languages[0]) || navigator.language || 'en';
}

function clampNum(v, min, max) { return Math.max(min, Math.min(max, v)); }
function resolveFxProfileName(name) { return FX_PRESETS[name] ? name : 'boost'; }
function getFxCount(n) { return Math.max(1, Math.round(n * (fxTuning.particles || 1))); }
function applyFxProfile(name, silent) {
  fxProfile = resolveFxProfileName(name);
  fxTuning = FX_PRESETS[fxProfile];
  const sel = document.getElementById('fx-intensity-select');
  if (sel && sel.value !== fxProfile) sel.value = fxProfile;
  try { localStorage.setItem(STORAGE_KEYS.fxProfile, fxProfile); } catch (_) {}
  if (!silent) emitColorChainEvent('fxProfileChanged', { profile: fxProfile, tuning: Object.assign({}, fxTuning) });
  return fxProfile;
}

function clonePieceForSnapshot(piece) {
  if (!piece) return null;
  return { id: piece.id, row: piece.row, col: piece.col, cells: piece.cells.map(function(cell) { return cell.slice(); }), colors: piece.colors.slice() };
}
function getStateSnapshot() {
  return {
    mode: gameMode, locale: currentLocale, score: score || 0, turn: turn || 0,
    gameOver: !!gameOver, gameState: gameState,
    board: board ? board.map(function(r) { return r.slice(); }) : null,
    currentPiece: clonePieceForSnapshot(currentPiece),
    nextPiece: clonePieceForSnapshot(nextPiece),
    holdPiece: clonePieceForSnapshot(holdPiece),
    warningJunkCols: warningJunkCols.slice(), pendingJunkCols: pendingJunkCols.slice(),
    gameplaySeed: gameplaySeed, gameplayRngState: gameplayRngState,
  };
}

// ═══ DROP SPEED ═══
function getDropInterval() {
  return Math.max(DROP_INTERVAL_MIN, DROP_INTERVAL_START - turn * 0.12);
}

// ═══ VOLUME / MUTE ═══
function loadVolumePrefs() {
  try {
    var sv = localStorage.getItem(STORAGE_KEYS.volume);
    if (sv !== null) masterVolume = clampNum(parseFloat(sv), 0, 1);
    var sm = localStorage.getItem(STORAGE_KEYS.muted);
    if (sm !== null) muted = sm === 'true';
  } catch (_) {}
  updateMuteUI();
}
function saveVolumePrefs() {
  try { localStorage.setItem(STORAGE_KEYS.volume, String(masterVolume)); localStorage.setItem(STORAGE_KEYS.muted, String(muted)); } catch (_) {}
}
function updateMuteUI() {
  var btn = document.getElementById('mute-btn');
  if (btn) { btn.textContent = muted ? '♪✕' : '♪'; btn.classList.toggle('muted', muted); }
  var slider = document.getElementById('vol-slider');
  if (slider) { slider.value = Math.round(masterVolume * 100); }
  var valEl = document.getElementById('vol-slider-val');
  if (valEl) { valEl.textContent = Math.round(masterVolume * 100) + '%'; }
}
function toggleMute() {
  muted = !muted; saveVolumePrefs(); updateMuteUI();
}

// ═══ PAUSE ═══
function togglePause() {
  if (gameOver || gameMode === 'versus' || countdownActive) return;
  paused = !paused;
  var overlay = document.getElementById('pause-overlay');
  if (overlay) overlay.classList.toggle('show', paused);
}

// ═══ MATCH PANEL VISIBILITY ═══
function updateMatchPanelVisibility() {
  var panel = document.getElementById('match-panel');
  if (!panel) return;
  var show = gameMode === 'versus' || netClient.connected || netClient.connecting || netClient.queued || netClient.inMatch;
  panel.classList.toggle('collapsed', !show);
}

// ═══ COUNTDOWN ═══
function startMatchCountdown(onDone) {
  countdownActive = true;
  var overlay = document.getElementById('countdown-overlay');
  var numEl = document.getElementById('countdown-number');
  if (!overlay || !numEl) { countdownActive = false; if (onDone) onDone(); return; }
  overlay.classList.add('show');
  var count = 3;
  numEl.textContent = count;
  numEl.style.animation = 'none'; void numEl.offsetWidth; numEl.style.animation = '';
  var iv = setInterval(function() {
    count--;
    if (count > 0) {
      numEl.textContent = count;
      numEl.style.animation = 'none'; void numEl.offsetWidth; numEl.style.animation = '';
    } else if (count === 0) {
      numEl.textContent = 'GO!';
      numEl.style.animation = 'none'; void numEl.offsetWidth; numEl.style.animation = '';
    } else {
      clearInterval(iv);
      overlay.classList.remove('show');
      countdownActive = false;
      if (onDone) onDone();
    }
  }, 1000);
}

// ═══ SOUND (Web Audio API — spatial stereo panning) ═══
let _audioCtx = null;
const _bufferCache = {};
const _bufferLoading = {};
const _SFX_MAP = {
  win: 'assets/sounds/win.wav', lose: 'assets/sounds/lose.wav',
  button: 'assets/sounds/button.wav', coins: 'assets/sounds/coins.wav',
  error: 'assets/sounds/error.wav',
  burst: 'assets/sounds/burst.wav', drop: 'assets/sounds/drop.wav',
  merge: 'assets/sounds/merge.wav',
  combo1: 'assets/sounds/combo1.wav', combo2: 'assets/sounds/combo2.wav',
  combo3: 'assets/sounds/combo3.wav', combo4: 'assets/sounds/combo4.wav'
};
function _getAudioCtx() {
  if (_audioCtx) return _audioCtx;
  try { _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (_) {}
  return _audioCtx;
}
function _resumeAudioCtx() {
  var ctx = _getAudioCtx();
  if (ctx && ctx.state === 'suspended') ctx.resume().catch(function(){});
  return ctx;
}
function _loadOneBuffer(name) {
  var ctx = _getAudioCtx(); if (!ctx) return;
  var url = _SFX_MAP[name]; if (!url) return;
  if (_bufferCache[name] || _bufferLoading[name]) return;
  _bufferLoading[name] = true;
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url, true);
  xhr.responseType = 'arraybuffer';
  xhr.onload = function() {
    if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
      ctx.decodeAudioData(xhr.response, function(buf) {
        _bufferCache[name] = buf;
        _bufferLoading[name] = false;
      }, function() { _bufferLoading[name] = false; });
    } else { _bufferLoading[name] = false; }
  };
  xhr.onerror = function() { _bufferLoading[name] = false; };
  xhr.send();
}
function _preloadAllBuffers() {
  Object.keys(_SFX_MAP).forEach(_loadOneBuffer);
}
// Eagerly create AudioContext + start preloading (works even while suspended)
_getAudioCtx();
_preloadAllBuffers();
// Resume on first user interaction (browser autoplay policy)
['pointerdown','keydown','touchstart'].forEach(function(evt) {
  document.addEventListener(evt, function() {
    _resumeAudioCtx();
    _preloadAllBuffers();
  }, { once: true });
});

function colToPan(col) {
  return ((col / (COLS - 1)) * 2 - 1) * 0.8;
}

function playSfx(name, opts) {
  if (muted) return;
  opts = opts || {};
  const defaults = {
    win:    { volume: 0.85, rate: 1.00, rateJitter: 0.01 },
    lose:   { volume: 0.80, rate: 1.00, rateJitter: 0.01 },
    button: { volume: 0.55, rate: 1.00, rateJitter: 0.04 },
    coins:  { volume: 0.65, rate: 1.00, rateJitter: 0.08 },
    burst:  { volume: 0.70, rate: 1.00, rateJitter: 0.05 },
    error:  { volume: 0.60, rate: 1.00, rateJitter: 0.03 },
    drop:   { volume: 0.65, rate: 1.00, rateJitter: 0.10 },
    merge:  { volume: 0.60, rate: 1.00, rateJitter: 0.10 },
    combo1: { volume: 0.70, rate: 1.00, rateJitter: 0.02 },
    combo2: { volume: 0.75, rate: 1.00, rateJitter: 0.02 },
    combo3: { volume: 0.80, rate: 1.00, rateJitter: 0.02 },
    combo4: { volume: 0.85, rate: 1.00, rateJitter: 0.02 }
  };
  const cfg = Object.assign({}, defaults[name] || {}, opts);
  const url = _SFX_MAP[name]; if (!url) return;
  const baseRate = Number.isFinite(cfg.rate) ? cfg.rate : 1;
  const jitter = Number.isFinite(cfg.rateJitter) ? cfg.rateJitter : 0;
  const rate = clampNum(baseRate + (Math.random() * 2 - 1) * jitter, 0.65, 1.75);
  const volume = clampNum((Number.isFinite(cfg.volume) ? cfg.volume : 1) * (fxTuning.audio || 1) * masterVolume, 0, 1);
  const pan = clampNum(Number.isFinite(cfg.pan) ? cfg.pan : 0, -1, 1);
  const ctx = _resumeAudioCtx();

  // ① Best path: preloaded AudioBuffer → full Web Audio
  if (ctx && _bufferCache[name]) {
    try {
      var src = ctx.createBufferSource();
      src.buffer = _bufferCache[name];
      src.playbackRate.value = rate;
      var gain = ctx.createGain();
      gain.gain.value = volume;
      var panner = ctx.createStereoPanner();
      panner.pan.value = pan;
      src.connect(panner).connect(gain).connect(ctx.destination);
      src.start(0, Number.isFinite(cfg.startAt) ? Math.max(0, cfg.startAt) : 0);
      return;
    } catch (_) {}
  }

  // ② Fallback: Audio element routed through Web Audio for panning
  //    (skipped on file:// — CORS blocks MediaElementSource)
  if (ctx && ctx.createStereoPanner && location.protocol !== 'file:') {
    try {
      var a2 = new Audio(url);
      try { a2.playbackRate = rate; } catch (_) {}
      var ms = ctx.createMediaElementSource(a2);
      var pn = ctx.createStereoPanner();
      pn.pan.value = pan;
      var gn = ctx.createGain();
      gn.gain.value = volume;
      ms.connect(pn).connect(gn).connect(ctx.destination);
      a2.play().catch(function(){});
      if (!_bufferCache[name]) _loadOneBuffer(name);
      return;
    } catch (_) {}
  }

  // ③ Last resort: plain HTML Audio (no panning)
  var a = new Audio(url);
  try { a.playbackRate = rate; } catch (_) {}
  try { a.volume = volume; } catch (_) {}
  try { a.currentTime = Number.isFinite(cfg.startAt) ? Math.max(0, cfg.startAt) : 0; } catch (_) {}
  a.play().catch(function() {});
}


// ═══ BOARD FLASH ═══
function pushParticle(p) {
  particles.push(p);
  const maxParticles = fxProfile === 'boost' ? 500 : fxProfile === 'normal' ? 350 : 180;
  if (particles.length > maxParticles) particles.splice(0, particles.length - maxParticles);
}
function pushRing(r) {
  rings.push(r);
  if (rings.length > 20) rings.splice(0, rings.length - 20);
}
function pushFloatingText(f) {
  if (f && f.channel === 'combo-banner') {
    comboBannerTexts.push(f);
    if (comboBannerTexts.length > 20) comboBannerTexts.splice(0, comboBannerTexts.length - 20);
    return;
  }
  floatingTexts.push(f);
  if (floatingTexts.length > 20) floatingTexts.splice(0, floatingTexts.length - 20);
}
function clearFloatingTextChannel(channel) {
  if (!channel) return;
  for (var i = floatingTexts.length - 1; i >= 0; i--) {
    if (floatingTexts[i] && floatingTexts[i].channel === channel) floatingTexts.splice(i, 1);
  }
  for (var i = comboBannerTexts.length - 1; i >= 0; i--) {
    if (comboBannerTexts[i] && comboBannerTexts[i].channel === channel) comboBannerTexts.splice(i, 1);
  }
}
function drawPremiumText(ctx, f) {
  var chain = f.chainLevel || 2;
  var pal = COMBO_PALETTES[Math.min(Math.max(chain, 2), 5)];
  var fontFam = f.font ? ("'" + f.font + "', ") : '';
  var fontStr = '900 ' + f.size + 'px ' + fontFam + 'LilitaOne, Outfit';
  ctx.font = fontStr;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.lineJoin = 'round';
  // Metallic gradient fill
  var m = ctx.measureText(f.text);
  var gh = f.size * 0.6;
  var grad = ctx.createLinearGradient(0, -gh, 0, gh);
  grad.addColorStop(0, pal.top);
  grad.addColorStop(0.45, pal.mid);
  grad.addColorStop(0.55, pal.mid);
  grad.addColorStop(1, pal.bot);
  // Layer 1: Wide outer glow (shadow)
  ctx.save();
  ctx.shadowColor = 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0.7)';
  ctx.shadowBlur = 18 + chain * 3;
  ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
  ctx.fillStyle = grad;
  ctx.fillText(f.text, 0, 0);
  ctx.restore();
  // Layer 2: Narrow inner glow
  ctx.save();
  ctx.shadowColor = 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0.5)';
  ctx.shadowBlur = 8;
  ctx.fillStyle = grad;
  ctx.fillText(f.text, 0, 0);
  ctx.restore();
  // Layer 3: Dark outer stroke (emboss)
  ctx.strokeStyle = pal.stroke;
  ctx.lineWidth = 6;
  ctx.strokeText(f.text, 0, 0);
  // Layer 4: Gradient fill
  ctx.fillStyle = grad;
  ctx.fillText(f.text, 0, 0);
  // Layer 5: Bright inner stroke (emboss highlight)
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 1.5;
  ctx.strokeText(f.text, 0, 0);
  // Layer 6: Specular highlight (top half clip)
  ctx.save();
  ctx.beginPath();
  var hw = m.width * 0.6 + 10;
  ctx.rect(-hw, -gh - 4, hw * 2, gh + 2);
  ctx.clip();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#fff';
  ctx.fillText(f.text, 0, -1);
  ctx.restore();
}
function drawComboAura(ctx) {
  if (!comboAura.active) return;
  comboAura.life -= 0.012;
  if (comboAura.life <= 0) { comboAura.active = false; return; }
  var ax = comboAura.x, ay = comboAura.y;
  var chain = comboAura.chain;
  var pal = COMBO_PALETTES[Math.min(Math.max(chain, 2), 5)];
  var alpha = Math.min(comboAura.life, 1) * 0.6;
  var t = (Date.now() - comboAura.startTime) * 0.001;
  // Background elliptical glow
  ctx.save();
  ctx.globalAlpha = alpha * 0.5;
  ctx.translate(ax, ay);
  ctx.scale(2.2, 0.7);
  var rg = ctx.createRadialGradient(0, 0, 0, 0, 0, 50 + chain * 8);
  rg.addColorStop(0, 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0.5)');
  rg.addColorStop(0.5, 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0.15)');
  rg.addColorStop(1, 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0)');
  ctx.fillStyle = rg;
  ctx.beginPath();
  ctx.arc(0, 0, 50 + chain * 8, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  // Rotating light streaks (2-3 around center)
  var streakCount = chain >= 4 ? 3 : 2;
  for (var si = 0; si < streakCount; si++) {
    var angle = t * (1.2 + si * 0.4) + si * (Math.PI * 2 / streakCount);
    var rx = 60 + chain * 6, ry = 18 + chain * 2;
    var sx = ax + Math.cos(angle) * rx;
    var sy = ay + Math.sin(angle) * ry;
    ctx.save();
    ctx.globalAlpha = alpha * (0.4 + 0.2 * Math.sin(t * 3 + si));
    var sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, 12 + chain * 2);
    sg.addColorStop(0, 'rgba(255,255,255,0.8)');
    sg.addColorStop(0.4, 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0.4)');
    sg.addColorStop(1, 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0)');
    ctx.fillStyle = sg;
    ctx.beginPath();
    ctx.arc(sx, sy, 12 + chain * 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  // Central bloom pulse
  ctx.save();
  var bloomPulse = 0.5 + 0.5 * Math.sin(t * 4);
  ctx.globalAlpha = alpha * 0.3 * bloomPulse;
  ctx.translate(ax, ay);
  var bg = ctx.createRadialGradient(0, 0, 0, 0, 0, 30 + chain * 5);
  bg.addColorStop(0, 'rgba(255,255,255,0.6)');
  bg.addColorStop(1, 'rgba(' + pal.glow[0] + ',' + pal.glow[1] + ',' + pal.glow[2] + ',0)');
  ctx.fillStyle = bg;
  ctx.beginPath();
  ctx.arc(0, 0, 30 + chain * 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}
function updateAndDrawFloatingTexts(list, drawCtx) {
  for (var i = list.length-1; i >= 0; i--) {
    var f = list[i];
    f.y += f.vy; f.vy *= .97; f.life -= f.decay;
    if (f.scale) f.scale = Math.max(1, f.scale - .03);
    if (f.life <= 0) { list.splice(i,1); continue; }
    if (f.x < -PAD*1.2 || f.x > BOARD_W + PAD*1.2 || f.y < -PAD*1.6 || f.y > BOARD_H + PAD*1.8) { list.splice(i,1); continue; }
    drawCtx.save();
    drawCtx.globalAlpha = Math.min(f.life,1);
    var s = f.scale || 1;
    drawCtx.translate(f.x, f.y);
    drawCtx.scale(s, s);
    if (f.premium) {
      drawPremiumText(drawCtx, f);
    } else {
      drawCtx.fillStyle = f.color;
      var fontFam = f.font ? ("'" + f.font + "', ") : '';
      drawCtx.font = '900 ' + f.size + 'px ' + fontFam + 'LilitaOne, Outfit';
      drawCtx.textAlign = 'center';
      drawCtx.textBaseline = 'middle';
      drawCtx.strokeStyle = 'rgba(0,0,0,.45)';
      drawCtx.lineWidth = f.font ? 4 : 3;
      drawCtx.lineJoin = 'round';
      drawCtx.strokeText(f.text, 0, 0);
      drawCtx.fillText(f.text, 0, 0);
    }
    drawCtx.restore();
  }
}
function drawComboBannerOverlay(sx, sy, sr) {
  if (!comboBannerCtx || !comboBannerCanvasEl) return;
  comboBannerCtx.clearRect(0, 0, comboBannerCanvasEl.width, comboBannerCanvasEl.height);
  if (!comboBannerTexts.length && !comboParticles.length && !comboAura.active) return;
  comboBannerCtx.save();
  comboBannerCtx.translate(PAD + sx, PAD + sy);
  if (sr) {
    comboBannerCtx.translate(BOARD_W/2, BOARD_H/2);
    comboBannerCtx.rotate(sr);
    comboBannerCtx.translate(-BOARD_W/2, -BOARD_H/2);
  }
  // Clip combo banner to board area
  comboBannerCtx.beginPath();
  comboBannerCtx.rect(0, 0, BOARD_W, BOARD_H);
  comboBannerCtx.clip();
  // Combo aura glow behind everything
  drawComboAura(comboBannerCtx);
  // Combo particles behind text
  updateComboParticles();
  drawComboParticles(comboBannerCtx);
  updateAndDrawFloatingTexts(comboBannerTexts, comboBannerCtx);
  comboBannerCtx.restore();
}
function pushImpactBurst(b) {
  impactBursts.push(b);
  if (impactBursts.length > 24) impactBursts.splice(0, impactBursts.length - 24);
}
function addShake(amount, opts) {
  opts = opts || {};
  const motion = fxTuning.motion || 1;
  shakeAmount = clampNum(Math.max(shakeAmount, amount * motion), 0, 72);
  shakeBiasX = clampNum(shakeBiasX + (opts.x || 0) * motion, -48, 48);
  shakeBiasY = clampNum(shakeBiasY + (opts.y || 0) * motion, -48, 48);
  shakeRot = clampNum(shakeRot + (opts.rot || 0) * motion, -0.08, 0.08);
}
function setScreenFlash(amount, rgb, focusX, focusY) {
  const scaled = clampNum(amount * (fxTuning.flash || 1), 0, 1);
  if (scaled <= 0) return;
  screenFlash = Math.max(screenFlash, scaled);
  if (Array.isArray(rgb) && rgb.length >= 3) screenFlashColor = [Math.floor(rgb[0]), Math.floor(rgb[1]), Math.floor(rgb[2])];
  if (Number.isFinite(focusX)) screenFlashFocusX = PAD + focusX;
  if (Number.isFinite(focusY)) screenFlashFocusY = PAD + focusY;
}
function setBoardPulse(amount, rgb, x, y) {
  boardPulse = Math.max(boardPulse, clampNum(amount, 0, 1));
  if (Array.isArray(rgb) && rgb.length >= 3) boardPulseColor = [Math.floor(rgb[0]), Math.floor(rgb[1]), Math.floor(rgb[2])];
  if (Number.isFinite(x)) boardPulseX = x;
  if (Number.isFinite(y)) boardPulseY = y;
}
function spawnImpactBurst(x, y, rgb, intensity) {
  const tint = rgb || [34, 211, 238];
  const lifeScale = clampNum(0.65 + (fxTuning.motion || 1) * 0.35, 0.45, 1.15);
  // Ripple rings instead of star spikes
  const ringCount = clampNum(Math.round(1 + intensity * 0.8), 1, 3);
  for (var ri = 0; ri < ringCount; ri++) {
    pushImpactBurst({
      x: x, y: y, rot: 0,
      spikes: 0, ripple: true,
      inner: 3 + ri * 6 + intensity * 2, outer: 12 + ri * 8 + intensity * 6,
      grow: 1.8 + intensity * 0.5, decay: (0.07 + ri * 0.015 + Math.random() * 0.02) / lifeScale,
      life: 1 - ri * 0.08, r: tint[0], g: tint[1], b: tint[2]
    });
  }
}
function resetPieceJellyFx(spawnKick) {
  pieceJellyFx.bounceTime = 0;
  pieceJellyFx.bounceAmp = 0;
  pieceJellyFx.wobbleAmp = 0;
  pieceJellyFx.wobblePhase = Math.random() * Math.PI * 2;
  pieceJellyFx.kickX = 0;
  pieceJellyFx.kickY = 0;
  pieceJellyFx.tilt = 0;
  pieceJellyFx.spawn = spawnKick ? 1 : 0;
}
function excitePieceJellyFx(kind, strength) {
  strength = clampNum(Number.isFinite(strength) ? strength : 1, 0.15, 2.5);
  const motion = clampNum(fxTuning && Number.isFinite(fxTuning.motion) ? fxTuning.motion : 1, 0.35, 1.35);
  const s = strength * motion;
  pieceJellyFx.bounceAmp = clampNum(pieceJellyFx.bounceAmp + 0.2 * s, 0, 1.35);
  pieceJellyFx.wobbleAmp = clampNum(pieceJellyFx.wobbleAmp + 0.16 * s, 0, 1.25);
  pieceJellyFx.wobblePhase += 0.6 + Math.random() * 0.55;
  if (kind === 'fall') {
    pieceJellyFx.bounceTime = 0;
    pieceJellyFx.kickY = clampNum(pieceJellyFx.kickY + 0.9 * s, -4.5, 6);
    pieceJellyFx.tilt = clampNum(pieceJellyFx.tilt + (Math.random() - 0.5) * 0.025 * s, -0.1, 0.1);
  } else if (kind === 'move') {
    pieceJellyFx.kickX = clampNum(pieceJellyFx.kickX + (Math.random() > 0.5 ? 1 : -1) * 0.9 * s, -7, 7);
    pieceJellyFx.tilt = clampNum(pieceJellyFx.tilt + (Math.random() - 0.5) * 0.045 * s, -0.12, 0.12);
  } else if (kind === 'rotate') {
    pieceJellyFx.bounceAmp = clampNum(pieceJellyFx.bounceAmp + 0.08 * s, 0, 1.4);
    pieceJellyFx.tilt = clampNum(pieceJellyFx.tilt + (Math.random() > 0.5 ? 1 : -1) * 0.05 * s, -0.16, 0.16);
  } else if (kind === 'spawn') {
    pieceJellyFx.spawn = 1;
    pieceJellyFx.bounceTime = 0;
    pieceJellyFx.bounceAmp = Math.max(pieceJellyFx.bounceAmp, 0.28 * s);
    pieceJellyFx.wobbleAmp = Math.max(pieceJellyFx.wobbleAmp, 0.2 * s);
  }
}
function updatePieceJellyFx(dt) {
  if (!Number.isFinite(dt) || dt <= 0) return;
  const step = dt / 16.6667;
  pieceJellyFx.bounceTime += dt;
  pieceJellyFx.bounceAmp = Math.max(0, pieceJellyFx.bounceAmp - 0.05 * step);
  pieceJellyFx.wobbleAmp = Math.max(0, pieceJellyFx.wobbleAmp - 0.03 * step);
  pieceJellyFx.spawn = Math.max(0, pieceJellyFx.spawn - 0.09 * step);
  pieceJellyFx.kickX *= Math.pow(0.72, step);
  pieceJellyFx.kickY *= Math.pow(0.68, step);
  pieceJellyFx.tilt *= Math.pow(0.75, step);
}
function exciteLockedCellJellyFx(keys, strength) {
  if (!keys || !keys.length) return;
  const motion = clampNum(fxTuning && Number.isFinite(fxTuning.motion) ? fxTuning.motion : 1, 0.35, 1.35);
  const s = clampNum((Number.isFinite(strength) ? strength : 1) * motion, 0.25, 3.5);
  const n = Math.max(keys.length - 1, 1);
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    var j = cellJelly[k];
    if (!j) j = cellJelly[k] = { amp: 0, t: 0, phase: Math.random() * Math.PI * 2, kickX: 0, kickY: 0 };
    var spread = (i / n) - 0.5;
    j.amp = clampNum(Math.max(j.amp, 0.55 + s * 0.22), 0, 2.2);
    j.t = 0;
    j.phase += (Math.random() - 0.5) * 0.7;
    j.kickX = clampNum(j.kickX + spread * CELL * 0.08 * s + (Math.random() - 0.5) * CELL * 0.02 * s, -6, 6);
    j.kickY = clampNum(j.kickY - CELL * (0.03 + 0.04 * Math.min(s, 2.4)), -5.5, 2.2);
    cellScale[k] = Math.max(cellScale[k] || 1, 1.03 + 0.03 * Math.min(s, 2.5));
  }
}
function getCurrentPieceJellyTransform(piece, nowMs) {
  if (!piece) return { x: 0, y: 0, sx: 1, sy: 1, rot: 0 };
  const motion = clampNum(fxTuning && Number.isFinite(fxTuning.motion) ? fxTuning.motion : 1, 0.35, 1.35);
  const stretch = 0;
  const squashPrep = 0;

  const bounceWave = Math.sin(pieceJellyFx.bounceTime * 0.045) * pieceJellyFx.bounceAmp;
  const impact = Math.max(0, bounceWave);
  const rebound = Math.max(0, -bounceWave);
  const spawnWave = pieceJellyFx.spawn > 0 ? Math.sin((1 - pieceJellyFx.spawn) * Math.PI * 1.35) * pieceJellyFx.spawn : 0;

  const wobbleBase = pieceJellyFx.wobbleAmp + 0.015 * motion * (pieceJellyFx.spawn > 0 ? 1 : 0);
  const wobbleX = Math.sin(nowMs * 0.06 + pieceJellyFx.wobblePhase) * CELL * 0.1 * wobbleBase;
  const wobbleY = Math.cos(nowMs * 0.08 + pieceJellyFx.wobblePhase * 1.3) * CELL * 0.05 * wobbleBase;
  const rotWave = Math.sin(nowMs * 0.05 + pieceJellyFx.wobblePhase * 0.6) * 0.05 * wobbleBase;

  let sx = 1, sy = 1;
  sx *= 1 - stretch * 0.45;
  sy *= 1 + stretch;
  sx *= 1 + impact * 0.18 - rebound * 0.07 + squashPrep;
  sy *= 1 - impact * 0.22 + rebound * 0.12 - squashPrep * 0.7;
  sx *= 1 + spawnWave * 0.1;
  sy *= 1 - spawnWave * 0.09;

  return {
    x: wobbleX + pieceJellyFx.kickX,
    y: wobbleY + pieceJellyFx.kickY,
    sx: clampNum(sx, 0.82, 1.26),
    sy: clampNum(sy, 0.78, 1.34),
    rot: clampNum(rotWave + pieceJellyFx.tilt, -0.12, 0.12)
  };
}

function triggerBoardFlash(type) {
  const wrapper = document.getElementById('board-wrapper');
  if (!wrapper) return;
  wrapper.classList.remove('flash-in', 'flash-out');
  void wrapper.offsetWidth;
  wrapper.classList.add('flash-' + type);
}

// ═══ GAME MODE ═══
function setGameMode(mode, options) {
  gameMode = mode === 'versus' ? 'versus' : 'solo';
  if (gameMode !== 'versus') {
    matchRuntime.roomId = null; matchRuntime.playerId = 'local'; matchRuntime.outgoingAttack = null;
  }
  if (options && typeof options === 'object') {
    if (Object.prototype.hasOwnProperty.call(options, 'roomId')) matchRuntime.roomId = options.roomId;
    if (Object.prototype.hasOwnProperty.call(options, 'playerId')) matchRuntime.playerId = options.playerId;
    if (Object.prototype.hasOwnProperty.call(options, 'outgoingAttack') && typeof options.outgoingAttack === 'function') matchRuntime.outgoingAttack = options.outgoingAttack;
  }
  // Toggle layout for split-screen
  const boardsRow = document.getElementById('boards-row');
  if (boardsRow) boardsRow.classList.toggle('versus', gameMode === 'versus');
  if (gameMode === 'versus') {
    // Show WAITING overlay until first opponent_state arrives
    const oppOverlay = document.getElementById('opp-overlay');
    const oppOverlayText = document.getElementById('opp-overlay-text');
    if (oppOverlay) oppOverlay.classList.add('show');
    if (oppOverlayText) { oppOverlayText.textContent = 'WAITING...'; oppOverlayText.classList.remove('no-blink'); }
    setTimeout(resizeCrossCanvas, 50);
  } else {
    opponentBoard = null;
    const oppOverlay = document.getElementById('opp-overlay');
    if (oppOverlay) oppOverlay.classList.remove('show');
  }
  updateModeUI();
  updateMatchPanelVisibility();
  emitColorChainEvent('modeChanged', { mode: gameMode, roomId: matchRuntime.roomId, playerId: matchRuntime.playerId });
}

function normalizeIncomingAttack(packet) {
  if (typeof packet === 'number') return { type: 'garbage', power: Math.max(0, Math.floor(packet)), source: 'remote' };
  const p = packet || {};
  return {
    type: p.type || 'garbage',
    power: Math.max(0, Math.floor(p.power || 0)),
    cols: Array.isArray(p.cols) ? p.cols.map(function(v) { return Math.max(0, Math.min(COLS - 1, Math.floor(v))); }) : null,
    source: p.source || 'remote',
    fromPlayerId: p.fromPlayerId || null,
    meta: p.meta || null,
  };
}
function queueIncomingAttack(packet) {
  const normalized = normalizeIncomingAttack(packet);
  if (normalized.power <= 0 && (!normalized.cols || !normalized.cols.length)) return null;
  incomingAttackQueue.push(normalized);
  triggerBoardFlash('in');
  playSfx('error');
  if (gameMode === 'versus') spawnCrossAttack(false, normalized.power || 1, '#d04050');
  emitColorChainEvent('incomingAttackQueued', normalized);
  return normalized;
}
function pickRandomAttackCols(power) {
  const cols = [];
  for (let i = 0; i < power; i++) cols.push(Math.floor(randGame() * COLS));
  return cols;
}
function consumeIncomingAttackCols() {
  const result = [];
  while (incomingAttackQueue.length) {
    const atk = incomingAttackQueue.shift();
    if (atk.cols && atk.cols.length) result.push.apply(result, atk.cols);
    else result.push.apply(result, pickRandomAttackCols(atk.power));
  }
  if (result.length) emitColorChainEvent('incomingAttackConsumed', { cols: result.slice(), count: result.length });
  return result;
}
function buildOutgoingAttack(explosionCount, chain, points) {
  const power = Math.max(0, (explosionCount - 1)) + Math.max(0, chain - 1) + (chain >= 4 ? 1 : 0);
  if (power <= 0) return null;
  return { type: 'garbage', power: power, source: 'local', fromPlayerId: matchRuntime.playerId, turn: turn, chain: chain, explosionCount: explosionCount, points: points };
}
function publishOutgoingAttack(packet) {
  if (!packet) return;
  emitColorChainEvent('outgoingAttack', packet);
  triggerBoardFlash('out');
  playSfx('burst', { volume: 0.50, rate: 0.9 + Math.min((packet.chain || 1), 5) * 0.05, rateJitter: 0.04 });
  if (gameMode === 'versus') {
    spawnCrossAttack(true, packet.power, '#d08820');
    if ((packet.chain || 1) >= 4) spawnCrossAttack(true, 3, '#d04050');
    showOppAtkBadge(packet.power);
  }
  if (gameMode === 'versus' && typeof matchRuntime.outgoingAttack === 'function') {
    try { matchRuntime.outgoingAttack(packet); } catch (err) { console.error('[ColorChain:outgoingAttack]', err); }
  }
}

window.ColorChain = {
  version: '0.3.0',
  setLocale: setLocale, getLocale: function() { return currentLocale; },
  setFxProfile: applyFxProfile, getFxProfile: function() { return fxProfile; },
  setMode: setGameMode, getMode: function() { return gameMode; },
  on: onColorChainEvent, off: offColorChainEvent,
  queueIncomingAttack: queueIncomingAttack,
  getSnapshot: getStateSnapshot,
  start: function(options) { startGame(options || {}); },
  sendAction: function(action) { return performAction(action, 'remote'); }
};

function isLocalHostname(hostname) { return hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '[::1]'; }
function readQueryParam(name) { try { return new URLSearchParams(window.location.search).get(name); } catch (_) { return null; } }
function detectInitialFxProfile() {
  const raw = (readQueryParam('fx') || '').toLowerCase();
  if (raw) return resolveFxProfileName(raw);
  try {
    const saved = localStorage.getItem(STORAGE_KEYS.fxProfile);
    if (saved) return resolveFxProfileName(saved);
  } catch (_) {}
  try {
    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return 'safe';
  } catch (_) {}
  return 'boost';
}
function normalizeServerUrl(url) {
  let value = String(url || '').trim(); if (!value) return '';
  if (!/^wss?:\/\//i.test(value)) { const proto = window.location.protocol === 'https:' ? 'wss://' : 'ws://'; value = proto + value.replace(/^\/+/, ''); }
  try {
    const parsed = new URL(value);
    if (parsed.protocol !== 'ws:' && parsed.protocol !== 'wss:') return '';
    if (window.location.protocol === 'https:' && parsed.protocol === 'ws:' && !isLocalHostname(parsed.hostname)) parsed.protocol = 'wss:';
    return parsed.toString();
  } catch (_) { return ''; }
}
function getDefaultMatchServerUrl() {
  const fromQuery = normalizeServerUrl(readQueryParam('ws'));
  if (fromQuery) return fromQuery;
  const host = window.location.hostname, isFile = window.location.protocol === 'file:';
  if (isFile || isLocalHostname(host)) return 'ws://localhost:8787';
  const fromQueryHost = readQueryParam('wshost');
  if (fromQueryHost) { const built = normalizeServerUrl(fromQueryHost); if (built) return built; }
  return '';
}
function getMatchEls() {
  return {
    serverUrl: document.getElementById('match-server-url'),
    playerName: document.getElementById('match-player-name'),
    actionBtn: document.getElementById('match-action-btn'),
    leaveBtn: document.getElementById('match-leave-btn'),
    status: document.getElementById('match-status'),
    opponent: document.getElementById('match-opponent'),
    result: document.getElementById('match-result'),
    restartBtn: document.getElementById('restart-btn'),
    rematchBtn: document.getElementById('rematch-btn'),
    connDot: document.getElementById('match-conn-dot'),
  };
}
function makeDefaultPlayerName() { return 'Player-' + Math.floor(1000 + Math.random() * 9000); }
function loadMatchPrefs() {
  const explicitQueryUrl = normalizeServerUrl(readQueryParam('ws')) || normalizeServerUrl(readQueryParam('wshost'));
  const defaultUrl = getDefaultMatchServerUrl();
  let url = explicitQueryUrl || netClient.serverUrl || defaultUrl;
  let name = netClient.playerName || makeDefaultPlayerName();
  try {
    if (!explicitQueryUrl) url = localStorage.getItem(STORAGE_KEYS.matchServerUrl) || url;
    name = localStorage.getItem(STORAGE_KEYS.matchPlayerName) || name;
  } catch (_) {}
  netClient.serverUrl = normalizeServerUrl(url) || defaultUrl || '';
  netClient.playerName = String(name || makeDefaultPlayerName()).slice(0, 20);
}
function saveMatchPrefs() {
  const els = getMatchEls();
  if (els.serverUrl) netClient.serverUrl = normalizeServerUrl(els.serverUrl.value) || getDefaultMatchServerUrl() || '';
  if (els.playerName) netClient.playerName = (els.playerName.value || '').trim().slice(0, 20) || makeDefaultPlayerName();
  try {
    if (netClient.serverUrl) localStorage.setItem(STORAGE_KEYS.matchServerUrl, netClient.serverUrl);
    localStorage.setItem(STORAGE_KEYS.matchPlayerName, netClient.playerName);
  } catch (_) {}
  if (els.serverUrl && els.serverUrl.value !== netClient.serverUrl) els.serverUrl.value = netClient.serverUrl;
  if (els.playerName && els.playerName.value !== netClient.playerName) els.playerName.value = netClient.playerName;
}
function setMatchStatusKey(key, tone, vars) { netClient.statusKey = key || null; netClient.statusText = ''; netClient.statusTone = tone || ''; netClient.statusVars = vars || null; updateMatchUi(); }
function setMatchStatusText(text, tone) { netClient.statusKey = null; netClient.statusText = text || ''; netClient.statusTone = tone || ''; netClient.statusVars = null; updateMatchUi(); }
function getMatchStatusText() {
  if (netClient.statusText) return netClient.statusText;
  if (netClient.statusKey) return t(netClient.statusKey, netClient.statusVars || undefined);
  if (netClient.connecting) return t('net.connecting');
  if (netClient.inMatch) return t('net.matched');
  if (netClient.queued) return t('net.queued');
  if (netClient.connected) return t('net.connected');
  return t('net.readyPrompt');
}
function updateMatchUi() {
  const els = getMatchEls();
  if (!els.playerName) return;
  if (!netClient.playerName) loadMatchPrefs();
  if (els.serverUrl && els.serverUrl.value !== netClient.serverUrl && !els.serverUrl.matches(':focus')) els.serverUrl.value = netClient.serverUrl;
  if (els.serverUrl) els.serverUrl.disabled = netClient.connecting || netClient.connected;
  if (els.playerName.value !== netClient.playerName && !els.playerName.matches(':focus')) els.playerName.value = netClient.playerName;
  els.playerName.disabled = netClient.connecting || netClient.queued || netClient.inMatch;
  // Conn dot
  if (els.connDot) {
    if (netClient.inMatch) els.connDot.className = 'conn-dot in-match';
    else if (netClient.connected) els.connDot.className = 'conn-dot connected';
    else if (netClient.connecting) els.connDot.className = 'conn-dot connecting';
    else els.connDot.className = 'conn-dot offline';
  }
  // Single action button
  if (els.actionBtn) {
    if (netClient.connecting) {
      els.actionBtn.textContent = t('net.connecting');
      els.actionBtn.disabled = true;
    } else if (netClient.inMatch) {
      els.actionBtn.textContent = 'IN MATCH';
      els.actionBtn.disabled = true;
    } else if (netClient.queued) {
      els.actionBtn.textContent = t('net.cancelQueue');
      els.actionBtn.disabled = false;
    } else {
      els.actionBtn.textContent = t('net.findMatch');
      els.actionBtn.disabled = false;
    }
  }
  // Leave btn — only visible in match
  if (els.leaveBtn) {
    els.leaveBtn.textContent = t('net.leave');
    els.leaveBtn.disabled = !netClient.inMatch;
    els.leaveBtn.style.display = netClient.inMatch ? '' : 'none';
  }
  // Status
  const statusText = getMatchStatusText();
  if (els.status) {
    els.status.textContent = statusText;
    const VALID_TONES = ['ok', 'warn', 'bad'];
    const tone = VALID_TONES.includes(netClient.statusTone) ? netClient.statusTone : '';
    els.status.className = 'match-meta-val' + (tone ? ' ' + tone : '');
  }
  // Opponent
  if (els.opponent) {
    if (netClient.opponent) {
      let line = netClient.opponent.name || netClient.opponent.id || '-';
      if (netClient.lastRemoteState && typeof netClient.lastRemoteState.score === 'number') line += ' | ' + t('hud.score') + ' ' + formatInt(netClient.lastRemoteState.score || 0);
      if (netClient.lastRemoteState && typeof netClient.lastRemoteState.turn === 'number') line += ' | ' + t('hud.turn') + ' ' + formatInt(netClient.lastRemoteState.turn || 0);
      els.opponent.textContent = line; els.opponent.className = 'match-meta-val strong';
    } else { els.opponent.textContent = t('net.waiting'); els.opponent.className = 'match-meta-val'; }
  }
  // Result
  if (els.result) {
    if (netClient.lastResult === 'win') { els.result.textContent = t('net.result.win'); els.result.className = 'match-meta-val ok strong'; }
    else if (netClient.lastResult === 'lose') { els.result.textContent = t('net.result.lose'); els.result.className = 'match-meta-val bad strong'; }
    else if (netClient.lastResult === 'draw') { els.result.textContent = t('net.result.draw'); els.result.className = 'match-meta-val warn strong'; }
    else { els.result.textContent = '-'; els.result.className = 'match-meta-val'; }
  }
  if (els.restartBtn) { els.restartBtn.disabled = netClient.inMatch; els.restartBtn.style.opacity = netClient.inMatch ? '0.5' : ''; els.restartBtn.style.cursor = netClient.inMatch ? 'not-allowed' : ''; }
  if (els.rematchBtn) {
    const showRematch = gameOver && netClient.connected && !netClient.inMatch && !netClient.queued && netClient.lastResult !== null;
    els.rematchBtn.style.display = showRematch ? 'block' : 'none';
    els.rematchBtn.textContent = t('net.rematch');
  }
  // Opponent panel header
  const oppHeader = document.getElementById('opp-header');
  if (oppHeader) {
    if (netClient.opponent) {
      let ohLine = netClient.opponent.name || '-';
      if (netClient.lastRemoteState) ohLine += '  |  ' + formatInt(netClient.lastRemoteState.score || 0) + ' pts';
      oppHeader.textContent = ohLine;
    } else { oppHeader.textContent = ''; }
  }
  updateMatchPanelVisibility();
}
function sanitizeName(name) { return String(name || '').replace(/\s+/g, ' ').trim().slice(0, 20); }
function sendMatchMessage(type, payload) {
  if (!netClient.ws || netClient.ws.readyState !== WebSocket.OPEN) return false;
  const msg = Object.assign({ type: type }, payload || {});
  try { netClient.ws.send(JSON.stringify(msg)); return true; } catch (err) { console.error('[match:send]', err); return false; }
}
function clearMatchSessionState() {
  netClient.queued = false; netClient.inMatch = false; netClient.roomId = null;
  netClient.matchSeed = null; netClient.opponent = null; netClient.sentGameOverForRoomId = null;
  netClient.lastRemoteState = null; incomingAttackQueue = [];
  if (gameMode === 'versus') setGameMode('solo');
}
function closeMatchSocket(manualReason) {
  netClient._manualDisconnect = true; netClient._reconnectAttempts = 0;
  if (netClient._reconnectTimer) { clearTimeout(netClient._reconnectTimer); netClient._reconnectTimer = null; }
  if (netClient.ws) { try { netClient.ws.close(); } catch (_) {} }
  netClient.ws = null; netClient.connected = false; netClient.connecting = false;
  clearMatchSessionState();
  if (manualReason) setMatchStatusText(manualReason, 'warn'); else setMatchStatusKey('net.offline');
}
function connectMatchSocket(autoQueueAfterConnect) {
  if (netClient.connected || netClient.connecting) return;
  saveMatchPrefs();
  if (!netClient.serverUrl) { setMatchStatusKey('net.needServerUrl', 'bad'); return; }
  netClient.autoQueueAfterConnect = !!autoQueueAfterConnect;
  netClient.lastError = ''; netClient.connecting = true;
  setMatchStatusKey('net.connecting', 'warn');
  let ws;
  try { ws = new WebSocket(netClient.serverUrl); }
  catch (err) { netClient.connecting = false; setMatchStatusText('Connect failed: ' + (err && err.message ? err.message : String(err)), 'bad'); return; }
  netClient.ws = ws;
  ws.addEventListener('open', function() {
    netClient.connecting = false; netClient.connected = true; netClient._reconnectAttempts = 0;
    setMatchStatusKey('net.connected', 'ok');
    sendMatchMessage('hello', { name: sanitizeName(netClient.playerName) || makeDefaultPlayerName(), clientVersion: window.ColorChain && window.ColorChain.version ? window.ColorChain.version : 'unknown' });
    if (netClient.autoQueueAfterConnect) { netClient.autoQueueAfterConnect = false; requestQueueJoin(); }
    updateMatchUi();
  });
  ws.addEventListener('message', function(ev) { let msg; try { msg = JSON.parse(ev.data); } catch (_) { return; } handleMatchMessage(msg); });
  ws.addEventListener('error', function() { setMatchStatusText('Socket error', 'bad'); });
  ws.addEventListener('close', function() {
    const hadMatch = netClient.inMatch, wasQueued = netClient.queued, wasManual = netClient._manualDisconnect;
    netClient._manualDisconnect = false; netClient.ws = null; netClient.connected = false; netClient.connecting = false;
    clearMatchSessionState();
    if (!wasManual && netClient.serverUrl && netClient._reconnectAttempts < 1) {
      netClient._reconnectAttempts++;
      setMatchStatusKey('net.reconnecting', 'warn');
      netClient._reconnectTimer = setTimeout(function() {
        netClient._reconnectTimer = null;
        if (!netClient.connected && !netClient.connecting) connectMatchSocket(wasQueued || hadMatch);
      }, 2000);
    } else {
      netClient._reconnectAttempts = 0;
      if (hadMatch) setMatchStatusKey('net.socketClosed', 'bad'); else setMatchStatusKey('net.offline', 'warn');
    }
    updateMatchUi();
  });
}
function requestQueueJoin() { if (!netClient.connected) { connectMatchSocket(true); return; } if (netClient.inMatch) return; sendMatchMessage('queue_join', {}); setMatchStatusKey('net.queued', 'warn'); }
function requestQueueLeave() { if (!netClient.connected) return; sendMatchMessage('queue_leave', {}); netClient.queued = false; setMatchStatusKey('net.connected', 'ok'); }
function leaveCurrentMatch() { if (!netClient.inMatch) return; sendMatchMessage('leave_match', { roomId: netClient.roomId, reason: 'client_leave' }); clearMatchSessionState(); setMatchStatusText(t('net.leftMatch'), 'warn'); updateMatchUi(); }
function sendLocalMatchState(reason) {
  if (!netClient.inMatch || !netClient.roomId) return;
  if (!netClient.connected) return;
  const snapshot = getStateSnapshot();
  const boardPayload = board ? board.map(function(r) { return r.slice(); }) : null;
  console.log('[CC:sendState]', reason, 'rows:', boardPayload ? boardPayload.length : 0, 'inMatch:', netClient.inMatch);
  sendMatchMessage('state', {
    roomId: netClient.roomId, reason: reason || 'update',
    state: {
      score: snapshot.score, turn: snapshot.turn,
      gameOver: snapshot.gameOver, gameState: snapshot.gameState,
      board: boardPayload
    }
  });
}
function handleMatchFound(msg) {
  netClient.queued = false; netClient.inMatch = true; netClient.roomId = msg.roomId || null;
  netClient.matchSeed = msg.seed;
  if (msg.opponent) { netClient.opponent = { name: sanitizeName(msg.opponent.name), id: String(msg.opponent.id || '').slice(0, 40) }; }
  else { netClient.opponent = null; }
  netClient.lastResult = null; netClient.lastRemoteState = null; netClient.sentGameOverForRoomId = null;
  setMatchStatusKey('net.matched', 'ok');
  const playerId = msg.you && msg.you.id ? msg.you.id : (netClient.clientId || 'local');
  startGame({
    mode: 'versus', roomId: netClient.roomId, playerId: playerId,
    outgoingAttack: function(packet) { if (!netClient.inMatch || !netClient.roomId) return; sendMatchMessage('attack', { roomId: netClient.roomId, packet: packet }); },
    seed: msg.seed
  });
  startMatchCountdown(function() { sendLocalMatchState('match_start'); });
}
function showResultOverlay(result) {
  gameOver = true; dropTimer = 0;
  updateFinalScoreUI();
  const overlay = document.getElementById('game-over-overlay');
  const h2 = overlay ? overlay.querySelector('h2') : null;
  if (result === 'win') {
    if (h2) h2.textContent = t('overlay.victory');
    if (overlay) overlay.className = 'show result-win';
    playSfx('win');
  } else if (result === 'lose') {
    if (h2) h2.textContent = t('overlay.defeat');
    if (overlay) overlay.className = 'show result-lose';
    playSfx('lose');
  } else if (result === 'draw') {
    if (h2) h2.textContent = t('overlay.draw');
    if (overlay) overlay.className = 'show result-draw';
  } else {
    if (h2) h2.textContent = t('overlay.gameOver');
    if (overlay) overlay.className = 'show result-gameover';
  }
  const els = getMatchEls();
  if (els.rematchBtn) {
    const showRematch = netClient.connected && !netClient.inMatch && !netClient.queued && netClient.lastResult !== null;
    els.rematchBtn.style.display = showRematch ? 'block' : 'none';
  }
}
function handleMatchEnded(result, statusKey, tone) {
  netClient.lastResult = result || null; netClient.inMatch = false; netClient.queued = false;
  netClient.sentGameOverForRoomId = null; netClient.roomId = null; netClient.matchSeed = null;
  if (gameMode === 'versus') setGameMode('solo');
  if (statusKey) setMatchStatusKey(statusKey, tone || ''); else updateMatchUi();
  // Show/update result overlay
  if (result === 'win' || result === 'lose' || result === 'draw') {
    showResultOverlay(result);
  }
}
function handleMatchMessage(msg) {
  if (!msg || typeof msg.type !== 'string') return;
  switch (msg.type) {
    case 'welcome':
      netClient.clientId = msg.clientId || netClient.clientId;
      if (msg.name) netClient.playerName = msg.name;
      if (!netClient.inMatch && !netClient.queued) setMatchStatusKey('net.connected', 'ok');
      break;
    case 'queue_status':
      netClient.queued = !!msg.queued;
      if (netClient.queued) setMatchStatusKey('net.queued', 'warn');
      else if (!netClient.inMatch && netClient.connected) setMatchStatusKey('net.connected', 'ok');
      break;
    case 'match_found': handleMatchFound(msg); break;
    case 'opponent_attack':
      if (msg.packet) queueIncomingAttack(Object.assign({}, msg.packet, { source: 'remote' }));
      break;
    case 'opponent_state':
      netClient.lastRemoteState = msg.state || null;
      if (msg.opponent) netClient.opponent = msg.opponent;
      // Remove WAITING overlay on first opponent_state (opponent is live)
      {
        const _ov = document.getElementById('opp-overlay');
        const _ot = document.getElementById('opp-overlay-text');
        if (_ov) _ov.classList.remove('show');
        if (_ot) _ot.classList.add('no-blink');
      }
      // Update opponent board for split-screen
      if (msg.state && msg.state.board) {
        opponentBoard = msg.state.board;
        console.log('[CC:oppState] board received', msg.state.board.length, 'rows, nonzero:',
          msg.state.board.reduce(function(acc, row) { return acc + row.filter(function(v) { return v !== 0; }).length; }, 0));
      } else {
        console.log('[CC:oppState] NO board. state:', !!msg.state, 'board:', msg.state && msg.state.board);
      }
      updateMatchUi();
      break;
    case 'opponent_game_over': {
      netClient.lastRemoteState = Object.assign({}, netClient.lastRemoteState || {}, { score: msg.score, turn: msg.turn, gameOver: true });
      // Show opponent game over on their board
      const oppOverlayGO = document.getElementById('opp-overlay');
      const oppOverlayText = document.getElementById('opp-overlay-text');
      if (oppOverlayGO) oppOverlayGO.classList.add('show');
      if (oppOverlayText) { oppOverlayText.textContent = 'GAME OVER'; oppOverlayText.classList.add('no-blink'); }
      updateMatchUi();
      break;
    }
    case 'match_result':
      handleMatchEnded(msg.result, 'net.matchEnded', msg.result === 'win' ? 'ok' : (msg.result === 'draw' ? 'warn' : 'bad'));
      break;
    case 'opponent_left':
      handleMatchEnded('win', 'net.opponentLeft', 'warn');
      netClient.opponent = null;
      break;
    case 'error':
      setMatchStatusText(String(msg.message || 'Server error').slice(0, 200), 'bad');
      break;
  }
}
function initMatchPanel() {
  loadMatchPrefs();
  const els = getMatchEls();
  if (!els.playerName) return;
  if (els.serverUrl) els.serverUrl.value = netClient.serverUrl;
  els.playerName.value = netClient.playerName;
  if (els.actionBtn) {
    els.actionBtn.addEventListener('click', function() {
      playSfx('button');
      if (netClient.inMatch) return;
      if (netClient.queued) { requestQueueLeave(); return; }
      requestQueueJoin();
    });
  }
  if (els.leaveBtn) {
    els.leaveBtn.addEventListener('click', function() {
      playSfx('button');
      leaveCurrentMatch();
    });
  }
  if (els.serverUrl) els.serverUrl.addEventListener('change', saveMatchPrefs);
  els.playerName.addEventListener('change', saveMatchPrefs);
  els.playerName.addEventListener('blur', saveMatchPrefs);
  setMatchStatusKey('net.readyPrompt'); updateMatchUi();
  // Auto-connect 600ms after page load if server URL is present
  setTimeout(function() {
    if (!netClient.connected && !netClient.connecting && netClient.serverUrl) {
      connectMatchSocket(false);
    }
  }, 600);
}

onColorChainEvent('pieceLocked', function() { sendLocalMatchState('piece_locked'); });
onColorChainEvent('turnReady', function() { sendLocalMatchState('turn_ready'); });
// Periodic board sync safety-net: even if events are missed, board data arrives every 1s
setInterval(function() {
  if (netClient.inMatch && netClient.connected && gameMode === 'versus') sendLocalMatchState('interval');
}, 1000);
onColorChainEvent('gameOver', function(evt) {
  if (!netClient.inMatch || !netClient.roomId) return;
  if (netClient.sentGameOverForRoomId === netClient.roomId) return;
  netClient.sentGameOverForRoomId = netClient.roomId;
  sendMatchMessage('game_over', { roomId: netClient.roomId, score: evt.payload && typeof evt.payload.score === 'number' ? evt.payload.score : score, turn: evt.payload && typeof evt.payload.turn === 'number' ? evt.payload.turn : turn });
});

// ═══ BOARD ═══
function initBoard() { board = []; for (let r = 0; r < ROWS; r++) board.push(new Array(COLS).fill(0)); }
function randomLevel() { const w = [0, 40, 35, 25]; let roll = randGame() * 100; for (let i = 1; i <= 3; i++) { roll -= w[i]; if (roll <= 0) return i; } return 1; }

// ═══ PIECES ═══
function createPiece() {
  let roll = randGame() * SHAPE_WEIGHT_SUM; let idx = 0;
  for (let i = 0; i < SHAPE_WEIGHTS.length; i++) { roll -= SHAPE_WEIGHTS[i]; if (roll <= 0) { idx = i; break; } }
  const tmpl = SHAPES[idx];
  return { cells: tmpl.cells.map(c => [...c]), colors: tmpl.cells.map(() => randomLevel()), row: 0, col: Math.floor(COLS / 2) - (idx >= 2 ? 1 : 0), id: tmpl.id };
}
function getDefaultCells(id) { const t = SHAPES.find(s => s.id === id); return t ? t.cells.map(c => [...c]) : [[0,0]]; }
function getDefaultCol(id) { const i = SHAPES.findIndex(s => s.id === id); return Math.floor(COLS / 2) - (i >= 2 ? 1 : 0); }
function tryRotate(piece, fn) {
  if (piece.cells.length === 1) return;
  const nc = piece.cells.map(fn);
  const mr = Math.min(...nc.map(s => s[0])), mc = Math.min(...nc.map(s => s[1]));
  const rotatedCells = nc.map(([r, c]) => [r - mr, c - mc]);
  // Wall kick offsets: [rowOffset, colOffset]
  const kicks = [[0,0],[0,-1],[0,1],[0,-2],[0,2]];
  // I3 (3-cell line): also try shifting up by 1 row (only if not already at top)
  if (piece.id === 'I3' && piece.row > 0) kicks.push([-1,0],[-1,-1],[-1,1]);
  for (const [kr, kc] of kicks) {
    let valid = true;
    for (const [r, c] of rotatedCells) {
      const br = piece.row + kr + r, bc = piece.col + kc + c;
      if (bc < 0 || bc >= COLS || br >= ROWS) { valid = false; break; }
      if (br >= 0 && board[br][bc] !== 0) { valid = false; break; }
    }
    if (valid) { piece.cells = rotatedCells; piece.row += kr; piece.col += kc; return; }
  }
}
function rotateCW(p) { tryRotate(p, ([r, c]) => [c, -r]); }
function rotateCCW(p) { tryRotate(p, ([r, c]) => [-c, r]); }
function canMove(p, dr, dc) { for (const [sr, sc] of p.cells) { const nr = p.row+sr+dr, nc = p.col+sc+dc; if (nc < 0 || nc >= COLS || nr >= ROWS) return false; if (nr >= 0 && board[nr][nc] !== 0) return false; } return true; }
function canPlaceAt(p, row, col) { for (const [sr, sc] of p.cells) { const nr = row+sr, nc = col+sc; if (nc < 0 || nc >= COLS || nr >= ROWS) return false; if (nr >= 0 && board[nr][nc] !== 0) return false; } return true; }

// ═══ HOLD ═══
function doHold() {
  if (gameState !== 'playing' || gameOver || !currentPiece || holdUsedThisTurn) return;
  holdUsedThisTurn = true;
  if (holdPiece) {
    const saved = holdPiece;
    holdPiece = { cells: getDefaultCells(currentPiece.id), colors: [...currentPiece.colors], id: currentPiece.id };
    currentPiece = { cells: getDefaultCells(saved.id), colors: [...saved.colors], row: 0, col: getDefaultCol(saved.id), id: saved.id };
  } else {
    holdPiece = { cells: getDefaultCells(currentPiece.id), colors: [...currentPiece.colors], id: currentPiece.id };
    currentPiece = nextPiece; nextPiece = createPiece();
  }
  if (!canMove(currentPiece, 0, 0)) triggerGameOver();
  dropTimer = 0;
  resetPieceJellyFx(true);
  excitePieceJellyFx('spawn', 0.9);
}

// ═══ LOCK → REACTIONS ═══
function lockPiece(piece, landingStrength) {
  const TAG_BASE = 100;
  for (let i = 0; i < piece.cells.length; i++) {
    const r = piece.row + piece.cells[i][0], c = piece.col + piece.cells[i][1];
    if (r < 0) { triggerGameOver(); return; }
    board[r][c] = TAG_BASE + piece.colors[i];
  }
  applyGravityRaw();
  activeCells = new Set();
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { if (board[r][c] >= TAG_BASE) { board[r][c] = board[r][c] - TAG_BASE; activeCells.add(r + ',' + c); } }
  exciteLockedCellJellyFx(Array.from(activeCells), Number.isFinite(landingStrength) ? landingStrength : 1);
  turn++; holdUsedThisTurn = false; updateTurnUI(); comboCount = 0;
  playSfx('drop', { rate: 0.9 + Math.random() * 0.2, volume: 0.70, pan: colToPan(piece.col) });
  emitColorChainEvent('pieceLocked', { turn: turn, piece: clonePieceForSnapshot(piece), score: score });
  if (turn % HEAT_INTERVAL === 0) startHeat(); else { updateHeatBar(); startResolve(); }
}

// ═══ MERGE ═══
function processMerges() {
  if (activeCells.size === 0) return false;
  let merged = false, lastSvCol = 3; const nextActive = new Set(), processed = new Set();
  for (const key of activeCells) {
    if (processed.has(key)) continue;
    const parts2 = key.split(','); const r = Number(parts2[0]), c = Number(parts2[1]);
    if (board[r][c] <= 0 || board[r][c] > MAX_LEVEL) continue;
    const level = board[r][c];
    const group = [], visited = new Set(), stack = [{r, c}];
    while (stack.length) {
      const u = stack.pop(); const k = u.r + ',' + u.c;
      if (u.r < 0 || u.r >= ROWS || u.c < 0 || u.c >= COLS) continue;
      if (visited.has(k) || board[u.r][u.c] !== level) continue;
      visited.add(k); group.push(u);
      for (const [dr, dc] of DIRS) stack.push({r: u.r+dr, c: u.c+dc});
    }
    if (group.length < 2) continue;
    for (const g of group) processed.add(g.r + ',' + g.c);
    merged = true;
    // Survivor: bottom row → active cell (just placed or cascade survivor) → group centroid
    const centroidCol = group.reduce((s, g) => s + g.c, 0) / group.length;
    for (const g of group) g._act = activeCells.has(g.r + ',' + g.c);
    group.sort((a, b) => {
      if (a.r !== b.r) return b.r - a.r;
      if (a._act !== b._act) return b._act - a._act;
      return Math.abs(a.c - centroidCol) - Math.abs(b.c - centroidCol);
    });
    const sv = group[0]; lastSvCol = sv.c; const newLv = Math.min(level + (group.length - 1), MAX_LEVEL + 1);
    for (const g of group) board[g.r][g.c] = 0;
    board[sv.r][sv.c] = newLv; nextActive.add(sv.r + ',' + sv.c);
    // Activate neighbors of all group cells for cascade detection
    for (const g of group) { for (const [dr, dc] of DIRS) { const nr = g.r + dr, nc = g.c + dc; if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) { const nv = board[nr][nc]; if (nv > 0 && nv !== JUNK) nextActive.add(nr + ',' + nc); } } }
    const sx = sv.c * CELL + CELL / 2, sy = sv.r * CELL + CELL / 2;
    const rgb = COLOR_RGB[Math.min(newLv, MAX_LEVEL)] || [200,200,200];
    for (let i = 1; i < group.length; i++) {
      const g = group[i], gx = g.c*CELL+CELL/2, gy = g.r*CELL+CELL/2;
      const ang = Math.atan2(sy-gy, sx-gx);
      for (let j = 0; j < getFxCount(6); j++) {
        const a = ang + (Math.random() - .5) * .8;
        const sp = 1.6 + Math.random() * 2.4;
        pushParticle({
          x: gx, y: gy, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - .15,
          life: .95, decay: 0.024, size: 2.6 + Math.random() * 1.7,
          len: 8 + Math.random() * 6, width: 2 + Math.random() * 1.2,
          rot: a, vr: (Math.random() - .5) * .45, drag: 0.97, gravity: 0.03,
          shape: j % 2 ? 'spark' : 'shard',
          r: rgb[0], g: rgb[1], b: rgb[2]
        });
      }
    }
    for (let i = 0; i < getFxCount(4+group.length*2); i++) {
      const a = Math.random()*Math.PI*2, sp = 1+Math.random()*1.9;
      pushParticle({
        x:sx,y:sy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-.65,life:.78,decay:0.023,
        size:2+Math.random()*2.2,len:6+Math.random()*5,width:1.7+Math.random()*1.1,
        rot:a,vr:(Math.random()-.5)*.5,drag:0.965,gravity:0.025,shape:i%3===0?'spark':'shard',
        r:Math.min(rgb[0]+60,255),g:Math.min(rgb[1]+60,255),b:Math.min(rgb[2]+60,255)
      });
    }
    if (group.length >= 3) {
      pushRing({x:sx,y:sy,radius:3,maxR:CELL*1.2+group.length*5,life:1,spd:2.5,color:COLORS[Math.min(newLv,MAX_LEVEL)]});
      spawnImpactBurst(sx, sy, rgb, 0.4 + group.length * 0.08);
      setBoardPulse(0.08 + group.length * 0.02, rgb, sx, sy);
    }
    const pts = group.length * level * 15 * Math.max(comboCount, 1); score += pts;
    pushFloatingText({x:sx,y:sy,text:group.length>=3?t('fx.merge',{count:group.length,points:formatInt(pts)}):t('fx.points',{points:formatInt(pts)}),life:1.1,decay:0.02,vy:-1.3,size:group.length>=3?16:12,color:group.length>=3?'#06d6a0':'#fff',scale:1.2});
    cellScale[sv.r+','+sv.c] = 1.3+group.length*0.05; cellFlash[sv.r+','+sv.c] = {alpha:1.2,type:'white'};
    emitColorChainEvent('merge', { turn, level, groupSize: group.length, newLevel: newLv, points: pts, combo: comboCount });
  }
  if (merged) { playSfx('merge', { rate: 1.0 + Math.min(comboCount, 4) * 0.04, rateJitter: 0.08, volume: 0.65, pan: colToPan(lastSvCol) }); updateScoreUI(); addShake(6, { y: -2, rot: 0.003 }); activeCells = nextActive; }
  else activeCells = new Set();
  return merged;
}

// ═══ COMBO PARTICLES ═══
var comboParticles = [];
function spawnComboParticles(cx, cy, chain, color) {
  var T2 = Math.PI * 2;
  var count = 16 + chain * 8;
  // Parse color to RGB for glow
  var hex = color.replace('#','');
  var cr = parseInt(hex.substring(0,2),16)||180, cg = parseInt(hex.substring(2,4),16)||180, cb = parseInt(hex.substring(4,6),16)||180;
  for (var i = 0; i < count; i++) {
    var a = (T2 / count) * i + (Math.random()-0.5)*0.6;
    var sp = 1.8 + Math.random() * 3.5 + chain * 0.5;
    var type = i % 4 === 0 ? 'star' : i % 3 === 0 ? 'streak' : 'dot';
    comboParticles.push({
      x: cx + (Math.random()-0.5)*28, y: cy + (Math.random()-0.5)*16,
      vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 0.8,
      life: 0.7 + Math.random() * 0.5, decay: 0.02 + Math.random() * 0.01,
      size: type==='star' ? 2.5+Math.random()*2 : type==='streak' ? 1.5+Math.random()*1.5 : 1+Math.random(),
      r: cr, g: cg, b: cb, type: type, rot: Math.random() * T2
    });
  }
  // Bright center flash particles
  for (var i = 0; i < 6; i++) {
    var a = Math.random() * T2, sp = 0.5 + Math.random() * 1.5;
    comboParticles.push({
      x: cx, y: cy, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp,
      life: 0.4 + Math.random()*0.3, decay: 0.025, size: 3+Math.random()*2,
      r: 255, g: 255, b: 240, type: 'glow', rot: 0
    });
  }
  // Lens flare particles (cross-shaped, near text)
  var flareCount = chain >= 4 ? 3 : 2;
  for (var i = 0; i < flareCount; i++) {
    comboParticles.push({
      x: cx + (Math.random()-0.5)*40, y: cy + (Math.random()-0.5)*20,
      vx: (Math.random()-0.5)*0.6, vy: (Math.random()-0.5)*0.4,
      life: 0.6 + Math.random()*0.4, decay: 0.015, size: 6+Math.random()*4+chain,
      r: 255, g: 250, b: 220, type: 'flare', rot: Math.random() * T2
    });
  }
  // Shimmer sparkle particles (fast blinking dots)
  var shimCount = 8 + chain * 3;
  for (var i = 0; i < shimCount; i++) {
    var sa = Math.random() * T2, ssp = 0.8 + Math.random() * 2;
    comboParticles.push({
      x: cx + (Math.random()-0.5)*50, y: cy + (Math.random()-0.5)*24,
      vx: Math.cos(sa)*ssp, vy: Math.sin(sa)*ssp - 0.3,
      life: 0.5 + Math.random()*0.4, decay: 0.025 + Math.random()*0.015,
      size: 1 + Math.random()*1.5, r: Math.min(255,cr+80), g: Math.min(255,cg+80), b: Math.min(255,cb+80),
      type: 'shimmer', rot: Math.random() * T2, phase: Math.random() * T2
    });
  }
  if (comboParticles.length > 150) comboParticles.splice(0, comboParticles.length - 150);
}
function updateComboParticles() {
  for (var i = comboParticles.length - 1; i >= 0; i--) {
    var p = comboParticles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.97; p.vy *= 0.97; p.vy += 0.01;
    p.life -= p.decay; p.rot += 0.05;
    if (p.phase !== undefined) p.phase += 0.25;
    if (p.life <= 0) { comboParticles.splice(i, 1); }
  }
}
function drawComboParticles(ctx) {
  if (!comboParticles.length) return;
  var T2 = Math.PI * 2;
  for (var i = 0; i < comboParticles.length; i++) {
    var p = comboParticles[i], a = Math.min(p.life, 1);
    ctx.save();
    if (p.type === 'glow') {
      ctx.globalAlpha = a * 0.5;
      var g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
      g.addColorStop(0, 'rgba(255,255,255,0.6)');
      g.addColorStop(1, 'rgba('+p.r+','+p.g+','+p.b+',0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 2, 0, T2); ctx.fill();
    } else if (p.type === 'star') {
      ctx.globalAlpha = a * 0.85;
      ctx.translate(p.x, p.y); ctx.rotate(p.rot);
      ctx.fillStyle = 'rgba('+p.r+','+p.g+','+p.b+',1)';
      // 4-point star
      var s = p.size * a;
      ctx.beginPath();
      ctx.moveTo(0, -s*1.2); ctx.lineTo(s*0.3, -s*0.3); ctx.lineTo(s*1.2, 0);
      ctx.lineTo(s*0.3, s*0.3); ctx.lineTo(0, s*1.2); ctx.lineTo(-s*0.3, s*0.3);
      ctx.lineTo(-s*1.2, 0); ctx.lineTo(-s*0.3, -s*0.3); ctx.closePath(); ctx.fill();
      // White center
      ctx.globalAlpha = a * 0.6; ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(0, 0, s*0.35, 0, T2); ctx.fill();
    } else if (p.type === 'streak') {
      ctx.globalAlpha = a * 0.7;
      ctx.strokeStyle = 'rgba('+p.r+','+p.g+','+p.b+',1)';
      ctx.lineWidth = p.size * 0.6 * a; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx * 4, p.y - p.vy * 4); ctx.stroke();
    } else if (p.type === 'flare') {
      // Cross-shaped lens flare
      var fs = p.size * a;
      ctx.translate(p.x, p.y); ctx.rotate(p.rot);
      ctx.globalAlpha = a * 0.7;
      // Horizontal beam
      var fgH = ctx.createLinearGradient(-fs*2, 0, fs*2, 0);
      fgH.addColorStop(0, 'rgba('+p.r+','+p.g+','+p.b+',0)');
      fgH.addColorStop(0.4, 'rgba('+p.r+','+p.g+','+p.b+',0.6)');
      fgH.addColorStop(0.5, 'rgba(255,255,255,0.9)');
      fgH.addColorStop(0.6, 'rgba('+p.r+','+p.g+','+p.b+',0.6)');
      fgH.addColorStop(1, 'rgba('+p.r+','+p.g+','+p.b+',0)');
      ctx.fillStyle = fgH;
      ctx.fillRect(-fs*2, -fs*0.15, fs*4, fs*0.3);
      // Vertical beam
      var fgV = ctx.createLinearGradient(0, -fs*2, 0, fs*2);
      fgV.addColorStop(0, 'rgba('+p.r+','+p.g+','+p.b+',0)');
      fgV.addColorStop(0.4, 'rgba('+p.r+','+p.g+','+p.b+',0.6)');
      fgV.addColorStop(0.5, 'rgba(255,255,255,0.9)');
      fgV.addColorStop(0.6, 'rgba('+p.r+','+p.g+','+p.b+',0.6)');
      fgV.addColorStop(1, 'rgba('+p.r+','+p.g+','+p.b+',0)');
      ctx.fillStyle = fgV;
      ctx.fillRect(-fs*0.15, -fs*2, fs*0.3, fs*4);
      // Bright center dot
      ctx.globalAlpha = a * 0.9;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(0, 0, fs*0.3, 0, T2); ctx.fill();
    } else if (p.type === 'shimmer') {
      // Fast blinking sparkle dot
      var blink = 0.5 + 0.5 * Math.sin((p.phase || 0) + p.rot * 8);
      ctx.globalAlpha = a * 0.8 * blink;
      ctx.fillStyle = 'rgba('+p.r+','+p.g+','+p.b+',1)';
      var ss = p.size * a;
      ctx.translate(p.x, p.y); ctx.rotate(p.rot);
      // Tiny 4-point sparkle
      ctx.beginPath();
      ctx.moveTo(0, -ss*1.5); ctx.lineTo(ss*0.2, -ss*0.2);
      ctx.lineTo(ss*1.5, 0); ctx.lineTo(ss*0.2, ss*0.2);
      ctx.lineTo(0, ss*1.5); ctx.lineTo(-ss*0.2, ss*0.2);
      ctx.lineTo(-ss*1.5, 0); ctx.lineTo(-ss*0.2, -ss*0.2);
      ctx.closePath(); ctx.fill();
    } else {
      ctx.globalAlpha = a * 0.75;
      ctx.fillStyle = 'rgba('+Math.min(255,p.r+60)+','+Math.min(255,p.g+60)+','+Math.min(255,p.b+60)+',1)';
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size * a, 0, T2); ctx.fill();
    }
    ctx.restore();
  }
}

// ═══ EXPLOSIONS ═══
function processExplosions() {
  const ex = []; for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (board[r][c] > MAX_LEVEL) ex.push({r,c});
  if (!ex.length) return false;
  let centerX = 0, centerY = 0;
  for (const ep of ex) { centerX += ep.c*CELL+CELL/2; centerY += ep.r*CELL+CELL/2; }
  centerX /= ex.length; centerY /= ex.length;
  const chain = comboCount + 1; const pts = ex.length * 200 * chain; score += pts; updateScoreUI();
  // Sound: water burst + combo sfx per chain level
  var explosionPan = ((centerX / BOARD_W) * 2 - 1) * 0.7;
  playSfx('burst', { rate: 0.9 + Math.min(chain, 5) * 0.06, rateJitter: 0.05, volume: Math.min(0.55 + chain * 0.05, 0.80), pan: explosionPan });
  var comboKey = chain >= 5 ? 'combo4' : chain >= 4 ? 'combo3' : chain >= 3 ? 'combo2' : chain >= 2 ? 'combo1' : null;
  if (comboKey) playSfx(comboKey, { volume: Math.min(0.60 + chain * 0.06, 0.90), pan: explosionPan });
  if (chain >= 2 || (chain === 1 && ex.length >= 2)) clearFloatingTextChannel('combo-banner');
  const comboEl = document.getElementById('combo-display');
  if (chain >= 2) {
    comboEl.textContent = t('fx.chain',{chain});
    comboEl.className = 'active';
    var sc = chain>=5?2.1:chain>=4?1.8:chain>=3?1.55:1.35;
    var comboPal = COMBO_PALETTES[Math.min(Math.max(chain, 2), 5)];
    comboEl.style.background = 'linear-gradient(180deg,' + comboPal.top + ' 0%,' + comboPal.mid + ' 45%,' + comboPal.bot + ' 100%)';
    comboEl.style.webkitBackgroundClip = 'text'; comboEl.style.backgroundClip = 'text';
    comboEl.style.color = 'transparent';
    comboEl.style.textShadow = '0 0 12px rgba(' + comboPal.glow[0] + ',' + comboPal.glow[1] + ',' + comboPal.glow[2] + ',.5),0 0 24px rgba(' + comboPal.glow[0] + ',' + comboPal.glow[1] + ',' + comboPal.glow[2] + ',.25)';
    comboEl.style.animation = 'none'; comboEl.offsetHeight; comboEl.style.animation = 'combo-glow-pulse .8s ease-in-out';
    comboEl.style.transform = 'scale('+sc+')';
    setTimeout(function(){ comboEl.style.transform = 'scale(1)'; }, 180+chain*25);
  }
  // Flash color follows chain depth: light cyan → deep indigo
  const flashRgb = chain >= 5 ? [99, 102, 241] : chain >= 4 ? [34, 211, 238] : chain >= 3 ? [52, 211, 153] : chain >= 2 ? [103, 232, 249] : [165, 243, 252];
  setBoardPulse(Math.min(0.22 + chain * 0.06 + ex.length * 0.015, 0.72), flashRgb, centerX, centerY);
  setScreenFlash(Math.min(.38 + chain*.12 + ex.length*.018, 0.95), flashRgb, centerX, centerY);
  spawnImpactBurst(centerX, centerY, flashRgb, 0.95 + chain * 0.2);
  if (chain >= 4) spawnImpactBurst(centerX, centerY, chain >= 5 ? [99, 102, 241] : [165, 243, 252], 0.7 + chain * 0.12);
  // Pick water palette based on chain: gentle ripple (1) → tsunami (5+)
  const palIdx = Math.min(chain, WATER_CHAIN_PALETTES.length) - 1;
  const fwColors = WATER_CHAIN_PALETTES[Math.max(0, palIdx)].slice();
  const baseRgb = COLOR_RGB[MAX_LEVEL];

  for (const pos of ex) {
    const px = pos.c*CELL+CELL/2, py = pos.r*CELL+CELL/2;
    // Water splash condensation burst
    splashSpawn(px, py, Math.min(chain, 3), Math.min(board[pos.r][pos.c], MAX_LEVEL));
    /* TEMP OFF — old explosion particles
    const burstCount = Math.min(getFxCount(10 + chain * 3), 36);
    for (let i = 0; i < burstCount; i++) {
      const a = (Math.PI*2/burstCount)*i + (Math.random()-.5)*.8;
      const sp = 2.5 + Math.random()*3.5 + chain*.4;
      const fc = fwColors[i % fwColors.length];
      const rv = Math.max(0,Math.min(255,Math.floor(fc[0] + (Math.random() - 0.5) * 30)));
      const gv = Math.max(0,Math.min(255,Math.floor(fc[1] + (Math.random() - 0.5) * 30)));
      const bv = Math.max(0,Math.min(255,Math.floor(fc[2] + (Math.random() - 0.5) * 30)));
      const shp = i % 3 === 0 ? 'bubble' : 'shard';
      const grav = shp === 'bubble' ? -(0.02 + Math.random() * 0.02) : 0.035;
      pushParticle({x:px,y:py,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-1.5,life:0.9+chain*0.03,decay:0.018+Math.random()*.008,size:2.5+Math.random()*2.5,len:0,width:1.5+Math.random()*1.2,r:rv,g:gv,b:bv,shape:shp,drag:0.96,gravity:grav,rot:a,vr:(Math.random()-.5)*0.3});
    }
    const bubbleCount = Math.min(getFxCount(4 + chain * 2), 16);
    for (let i = 0; i < bubbleCount; i++) {
      const a = Math.random()*Math.PI*2, sp = 0.6+Math.random()*2;
      const ec = chain >= 2 ? fwColors[Math.floor(Math.random() * fwColors.length)] : [200, 240, 255];
      pushParticle({x:px,y:py,vx:Math.cos(a)*sp+(Math.random()-.5)*0.5,vy:-1-Math.random()*2,life:0.9+Math.random()*0.3,decay:.02+Math.random()*.008,size:2.5+Math.random()*2.5,len:0,width:0,r:Math.min(255,ec[0]+40),g:Math.min(255,ec[1]+40),b:Math.min(255,ec[2]+40),shape:'bubble',drag:0.97,gravity:-0.025,rot:0,vr:0});
    }
    if (chain >= 3) {
      const foamCount = Math.min(getFxCount(3 + chain), 12);
      for (let i = 0; i < foamCount; i++) {
        const a = Math.random()*Math.PI*2, sp = 0.5 + Math.random()*1.5;
        const gc = fwColors[Math.floor(Math.random() * fwColors.length)];
        pushParticle({x:px,y:py,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-0.5,life:0.8+Math.random()*0.3,decay:.02+Math.random()*.008,size:1.5+Math.random()*1.5,len:0,width:0,r:gc[0],g:gc[1],b:gc[2],shape:'dot',drag:0.97,gravity:-0.01,rot:0,vr:0});
      }
    }
    const ringColor = fwColors[Math.floor(Math.random() * fwColors.length)];
    const ringHex = '#' + ringColor.map(function(v){ return ('0'+Math.max(0,Math.min(255,v)).toString(16)).slice(-2); }).join('');
    pushRing({x:px,y:py,radius:5,maxR:CELL*1.5+chain*5,life:0.8,spd:2.5+chain*0.6,color:ringHex});
    spawnImpactBurst(px, py, fwColors[Math.floor(Math.random() * fwColors.length)], 0.5 + chain * 0.08);
    TEMP OFF */
    const ptColor = chain>=5?'#6a5acd':chain>=4?'#d08820':chain>=3?'#2a8a5a':chain>=2?'#3090b0':'#3a90b5';
    pushFloatingText({x:px+(Math.random()-.5)*8,y:py,text:t('fx.points',{points:formatInt(200*chain)}),life:1.5,decay:.014,vy:-2.2-chain*.2,size:chain>=3?24:chain>=2?20:16,color:ptColor,scale:1.5,premium:chain>=2,chainLevel:chain});
    cellFlash[pos.r+','+pos.c] = {alpha:2.5,type:'white'};
  }
  if (chain >= 2) {
    var chainColor2 = chain>=5?'#6a5acd':chain>=4?'#d08820':chain>=3?'#2a8a5a':'#3a90b5';
    pushFloatingText({x:BOARD_W/2,y:56,text:t('fx.chain',{chain}),life:1.35,decay:.02,vy:-.2,size:Math.min(28+chain*3,42),color:chainColor2,scale:Math.min(1.4+chain*0.04,1.65),channel:'combo-banner',font:'Black Han Sans',premium:true,chainLevel:chain});
    // Activate combo aura glow
    comboAura.active = true; comboAura.x = BOARD_W/2; comboAura.y = 56;
    comboAura.life = 1.4; comboAura.chain = chain; comboAura.startTime = Date.now();
    // Spawn combo particles (swirl/burst around text)
    spawnComboParticles(BOARD_W/2, 56, chain, chainColor2);
    if (chain >= 5) pushFloatingText({x:BOARD_W/2,y:82,text:'TSUNAMI!!',life:1.1,decay:.022,vy:-.15,size:16,color:'#2878a8',scale:1.15,channel:'combo-banner',font:'Black Han Sans',premium:true,chainLevel:chain});
    else if (chain >= 4) pushFloatingText({x:BOARD_W/2,y:80,text:'SPLASH!',life:1.0,decay:.024,vy:-.14,size:14,color:'#d08820',scale:1.1,channel:'combo-banner',font:'Black Han Sans',premium:true,chainLevel:chain});
  }
  if (chain === 1 && ex.length >= 2) pushFloatingText({x:BOARD_W/2,y:62,text:t('fx.boom'),life:0.95,decay:.026,vy:-.15,size:22,color:'#2878a8',scale:1.25,channel:'combo-banner'});
  hitstopTimer = Math.max(12, Math.round((chain>=5?140:chain>=4?105:chain>=3?75:chain>=2?50:30) * (fxTuning.hitstop || 1)));
  addShake(Math.min(14+chain*9+ex.length*1.1, 68), { x: ((centerX - BOARD_W / 2) / BOARD_W) * 26, y: -4 - chain * 1.3, rot: 0.004 + chain * 0.001 });
  for (const pos of ex) board[pos.r][pos.c] = 0;
  const affected = new Set(), junkDead = [];
  for (const pos of ex) for (const [dr, dc] of DIRS) {
    const nr = pos.r+dr, nc = pos.c+dc;
    if (nr < 0||nr >= ROWS||nc < 0||nc >= COLS) continue;
    if (board[nr][nc] === JUNK) { junkDead.push({r:nr,c:nc}); board[nr][nc] = 0; }
    else if (board[nr][nc] > 0) affected.add(nr+','+nc);
  }
  for (const jd of junkDead) {
    const jx = jd.c*CELL+CELL/2, jy = jd.r*CELL+CELL/2;
    spawnImpactBurst(jx, jy, JUNK_RGB, 0.45);
    for (let i = 0; i < getFxCount(6); i++) {
      const a = (Math.PI*2/6)*i+Math.random()*.6;
      pushParticle({x:jx,y:jy,vx:Math.cos(a)*2.2,vy:Math.sin(a)*2.2-1.1,life:.78,decay:.024,size:2.3+Math.random()*1.2,len:5+Math.random()*4,width:1.8+Math.random()*.9,r:JUNK_RGB[0],g:JUNK_RGB[1],b:JUNK_RGB[2],shape:i%2===0?'spark':'shard',drag:0.96,gravity:0.05,rot:a,vr:(Math.random()-.5)*.4});
    }
  }
  for (const k of affected) { const p2 = k.split(','); const ar = Number(p2[0]), ac = Number(p2[1]); board[ar][ac]++; cellFlash[k]={alpha:1,type:'warm'}; cellScale[k]=1.15; activeCells.add(k); }
  emitColorChainEvent('explosionResolve', { turn, chain, explosionCount: ex.length, points: pts });
  publishOutgoingAttack(buildOutgoingAttack(ex.length, chain, pts));
  return true;
}

// ═══ GRAVITY ═══
function applyGravityRaw() {
  for (let c = 0; c < COLS; c++) { let w = ROWS-1; for (let r = ROWS-1; r >= 0; r--) { if (board[r][c] !== 0) { if (r !== w) { board[w][c] = board[r][c]; board[r][c] = 0; } w--; } } }
}
const GRAV_TAG = 100;
function applyGravity() {
  const before = board.map(function(r){ return r.slice(); });
  for (const key of activeCells) { const p2 = key.split(','); const r = Number(p2[0]), c = Number(p2[1]); if (board[r][c] !== 0 && board[r][c] !== JUNK) board[r][c] = GRAV_TAG+board[r][c]; }
  applyGravityRaw();
  activeCells = new Set();
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { if (board[r][c] >= GRAV_TAG) { board[r][c] = board[r][c]-GRAV_TAG; activeCells.add(r+','+c); } }
  // Also mark cells that moved during gravity as active
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { if (board[r][c] !== 0 && board[r][c] !== JUNK && board[r][c] !== before[r][c]) activeCells.add(r+','+c); }
}

// ═══ HEAT ═══
function startHeat() { gameState='heat'; heatAnimTimer=0; preHeatBoard=board.map(function(r){return r.slice();}); for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]>0) board[r][c]++; addShake(5, { y: -2, rot: 0.002 }); emitColorChainEvent('heatStarted',{turn}); }
function updateHeat(dt) {
  heatAnimTimer += dt;
  const tl = Math.min(heatAnimTimer/HEAT_DURATION, 1); shakeAmount = Math.sin(tl*Math.PI) * (2 + 3 * (fxTuning.motion || 1));
  if (tl >= 1) { preHeatBoard=null; shakeAmount=0; shakeBiasX=0; shakeBiasY=0; shakeRot=0; updateHeatBar(); activeCells=new Set(); for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]>0) activeCells.add(r+','+c); comboCount=0; startResolve(); }
}
function updateHeatBar() { document.getElementById('heat-bar-fill').style.width = (turn % HEAT_INTERVAL) / HEAT_INTERVAL * 100 + '%'; }

// ═══ RESOLVE ═══
function startResolve() {
  var safety = 100;
  while (safety-- > 0) {
    if (processMerges()) { applyGravity(); comboCount++; continue; }
    if (processExplosions()) { applyGravity(); comboCount++; continue; }
    break;
  }
  updateHeatBar(); finishTurn();
}
function updateResolve(dt) { resolveTimer+=dt; if(resolveTimer>=RESOLVE_DELAY) doResolveStep(); }
function doResolveStep() { if(processMerges()){applyGravity();comboCount++;resolveTimer=0;return;} if(processExplosions()){applyGravity();comboCount++;resolveTimer=0;return;} updateHeatBar();finishTurn(); }

// ═══ JUNK ═══
function planNextJunk() {
  pendingJunkCols = []; const ne = turn+1-JUNK_START; if(ne<0) return;
  const intv = Math.max(3,JUNK_BASE_INT-Math.floor(ne/20)); if(ne%intv!==0) return;
  const cnt = Math.min(2+Math.floor(ne/15),4), used = new Set();
  for(let i=0;i<cnt;i++){let c,att=0;do{c=Math.floor(randGame()*COLS);att++;}while(used.has(c)&&att<10);used.add(c);pendingJunkCols.push(c);}
}
function spawnJunk(cols) {
  for(const c of cols){
    let placed=false;
    for(let r=0;r<ROWS;r++){if(board[r][c]!==0){if(r===0)break;board[r-1][c]=JUNK;cellScale[(r-1)+','+c]=1.4;cellFlash[(r-1)+','+c]={alpha:1,type:'white'};placed=true;break;}}
    if(!placed&&board[ROWS-1][c]===0){board[ROWS-1][c]=JUNK;cellScale[(ROWS-1)+','+c]=1.4;}
  }
  if(cols.length){pushFloatingText({x:BOARD_W/2,y:40,text:t('fx.junkWarning'),life:1,decay:.025,vy:-.3,size:14,color:'#d04050'});addShake(2, { y: -1, rot: 0.002 });emitColorChainEvent('junkSpawned',{turn,cols:cols.slice()});}
}
function updateJunkPreviewUi() {
  const badge = document.getElementById('junk-count-badge');
  const bar = document.getElementById('junk-col-bar');
  if (!badge || !bar) return;
  const total = warningJunkCols.length;
  badge.textContent = total;
  badge.className = total >= 4 ? 'danger' : total >= 2 ? 'warn' : '';
  bar.innerHTML = '';
  const colCounts = new Array(COLS).fill(0);
  warningJunkCols.forEach(function(c) { colCounts[c]++; });
  for (let c = 0; c < COLS; c++) {
    const dot = document.createElement('div');
    dot.className = 'junk-col-dot' + (colCounts[c] > 1 ? ' multi' : colCounts[c] > 0 ? ' active' : '');
    bar.appendChild(dot);
  }
}
function finishTurn() {
  if(warningJunkCols.length){spawnJunk(warningJunkCols);applyGravityRaw();}
  warningJunkCols = pendingJunkCols.slice();
  const incomingCols = consumeIncomingAttackCols();
  if(incomingCols.length){warningJunkCols=warningJunkCols.concat(incomingCols);emitColorChainEvent('incomingAttackPreview',{turn,cols:incomingCols.slice(),totalWarningCount:warningJunkCols.length});}
  planNextJunk();
  updateJunkPreviewUi();
  gameState='playing'; currentPiece=nextPiece; nextPiece=createPiece();
  resetPieceJellyFx(true);
  excitePieceJellyFx('spawn', 1.05);
  if(!canMove(currentPiece,0,0)) triggerGameOver();
  dropTimer=0;
  emitColorChainEvent('turnReady',{turn,warningJunkCols:warningJunkCols.slice(),pendingJunkCols:pendingJunkCols.slice()});
  setTimeout(function(){var el=document.getElementById('combo-display');el.textContent='';el.className='';el.style.background='';el.style.webkitBackgroundClip='';el.style.backgroundClip='';el.style.color='';el.style.textShadow='';el.style.animation='';},600);
}

function hardDrop() {
  if(gameState!=='playing'||gameOver||!currentPiece) return;
  var moved = 0;
  while(canMove(currentPiece,1,0)) { currentPiece.row++; moved++; }
  lockPiece(currentPiece, Math.min(2.4, 1 + moved * 0.18));
}
function triggerGameOver() {
  if (gameOver) return;
  gameOver = true; dropTimer = 0;
  updateFinalScoreUI();
  const overlay = document.getElementById('game-over-overlay');
  if (overlay) overlay.className = 'show result-gameover';
  if (gameMode !== 'versus') playSfx('lose');
  emitColorChainEvent('gameOver', { score, turn, snapshot: getStateSnapshot() });
}

// ═══ OPPONENT BOARD RENDERING ═══
function renderOpponentBoard() {
  if (!oppCtx) return;
  oppCtx.clearRect(0, 0, 216, 432);
  oppCtx.fillStyle = 'rgba(180,215,240,.55)'; oppCtx.fillRect(0, 0, 216, 432);
  oppCtx.strokeStyle = 'rgba(255,255,255,.35)'; oppCtx.lineWidth = 1;
  for (var r = 0; r <= ROWS; r++) { oppCtx.beginPath(); oppCtx.moveTo(0,r*CELL); oppCtx.lineTo(BOARD_W,r*CELL); oppCtx.stroke(); }
  for (var c = 0; c <= COLS; c++) { oppCtx.beginPath(); oppCtx.moveTo(c*CELL,0); oppCtx.lineTo(c*CELL,BOARD_H); oppCtx.stroke(); }
  if (!opponentBoard) return;
  var _dbgDrawn = 0;
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      if (opponentBoard[r][c] !== 0) { drawCell(oppCtx, c*CELL, r*CELL, opponentBoard[r][c], CELL); _dbgDrawn++; }
    }
  }
  if (_dbgDrawn > 0 && !renderOpponentBoard._logged) { renderOpponentBoard._logged = true; console.log('[CC:renderOpp] drawing cells, count:', _dbgDrawn); }
}

// ═══ CROSS-BOARD ATTACK CANVAS ═══
function resizeCrossCanvas() {
  const cc = document.getElementById('cross-canvas');
  const br = document.getElementById('boards-row');
  if (!cc || !br || !br.classList.contains('versus')) { if (cc) cc.style.display = 'none'; return; }
  cc.style.display = 'block';
  cc.width = br.offsetWidth;
  cc.height = br.offsetHeight;
  crossCtx = cc.getContext('2d');
}
var crossImpacts = [];
function spawnCrossAttack(outgoing, power, color) {
  var br = document.getElementById('boards-row');
  if (!br || !br.classList.contains('versus')) return;
  var cc = document.getElementById('cross-canvas');
  var mw = document.getElementById('board-wrapper');
  var ow = document.getElementById('opp-board-wrapper');
  if (!cc || !mw || !ow || cc.style.display === 'none') return;
  var cr = cc.getBoundingClientRect(), mr = mw.getBoundingClientRect(), or2 = ow.getBoundingClientRect();
  // Clear start/end: center-right of my board → center-left of opp board (or reverse)
  var srcCx = outgoing ? (mr.left - cr.left + mr.width * 0.75) : (or2.left - cr.left + or2.width * 0.25);
  var srcCy = outgoing ? (mr.top - cr.top + mr.height * 0.4) : (or2.top - cr.top + or2.height * 0.4);
  var tgtCx = outgoing ? (or2.left - cr.left + or2.width * 0.5) : (mr.left - cr.left + mr.width * 0.5);
  var tgtCy = outgoing ? (or2.top - cr.top + or2.height * 0.5) : (mr.top - cr.top + mr.height * 0.5);
  var count = Math.max(1, Math.min(power, 5));
  var col = color || (outgoing ? '#3ab8e0' : '#e05050');
  for (var i = 0; i < count; i++) {
    var spread = (i - (count-1)/2) * 18;
    crossProjectiles.push({
      sx: srcCx + (Math.random()-0.5)*20, sy: srcCy + spread,
      tx: tgtCx + (Math.random()-0.5)*15, ty: tgtCy + spread * 0.6,
      progress: 0, speed: 0.018 + Math.random() * 0.006,
      delay: i * 55,
      color: col, outgoing: outgoing,
      size: 4 + power * 0.5 + Math.random() * 2,
      trail: [], arcH: -(40 + Math.random() * 30 + power * 5) // parabola height
    });
  }
}
function drawCrossCanvas() {
  var cc = document.getElementById('cross-canvas');
  if (!cc || cc.style.display === 'none' || !crossCtx) return;
  crossCtx.clearRect(0, 0, cc.width, cc.height);
  var T2 = Math.PI * 2;
  // Draw impacts
  for (var i = crossImpacts.length - 1; i >= 0; i--) {
    var im = crossImpacts[i];
    im.life -= 0.035;
    if (im.life <= 0) { crossImpacts.splice(i, 1); continue; }
    var a = Math.min(im.life, 1);
    // Expanding ring
    var ring = (1 - im.life) * im.maxR;
    crossCtx.save(); crossCtx.globalAlpha = a * 0.6;
    crossCtx.strokeStyle = im.color; crossCtx.lineWidth = Math.max(1, 3 * a);
    crossCtx.beginPath(); crossCtx.arc(im.x, im.y, ring, 0, T2); crossCtx.stroke();
    // Flash
    crossCtx.globalAlpha = a * a * 0.3;
    var fg = crossCtx.createRadialGradient(im.x, im.y, 0, im.x, im.y, ring * 0.8);
    fg.addColorStop(0, 'rgba(255,255,255,0.5)'); fg.addColorStop(1, im.color.replace(')', ',0)').replace('rgb', 'rgba'));
    crossCtx.fillStyle = fg; crossCtx.beginPath(); crossCtx.arc(im.x, im.y, ring * 0.8, 0, T2); crossCtx.fill();
    crossCtx.restore();
    // Sparks
    for (var s = 0; s < im.sparks.length; s++) {
      var sp = im.sparks[s];
      sp.x += sp.vx; sp.y += sp.vy; sp.vy += 0.08; sp.life -= 0.04;
      if (sp.life <= 0) continue;
      crossCtx.save(); crossCtx.globalAlpha = sp.life * 0.8;
      crossCtx.strokeStyle = '#fff'; crossCtx.lineWidth = 1.2;
      crossCtx.beginPath(); crossCtx.moveTo(sp.x, sp.y);
      crossCtx.lineTo(sp.x - sp.vx * 3, sp.y - sp.vy * 3); crossCtx.stroke();
      crossCtx.restore();
    }
  }
  // Draw projectiles
  for (var i = crossProjectiles.length - 1; i >= 0; i--) {
    var p = crossProjectiles[i];
    if (p.delay > 0) { p.delay -= 16; continue; }
    p.progress += p.speed;
    if (p.progress >= 1) {
      // Spawn impact at target
      var sparks = [];
      for (var s = 0; s < 8; s++) {
        var sa = Math.random() * T2, ss = 2 + Math.random() * 4;
        sparks.push({ x: p.tx, y: p.ty, vx: Math.cos(sa)*ss, vy: Math.sin(sa)*ss, life: 0.6 + Math.random()*0.4 });
      }
      crossImpacts.push({ x: p.tx, y: p.ty, life: 1, maxR: 25 + p.size * 2, color: p.color, sparks: sparks });
      crossProjectiles.splice(i, 1); continue;
    }
    // Parabolic arc: linear lerp + arc offset
    var t = p.progress;
    var ease = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
    var cx2 = p.sx + (p.tx - p.sx) * ease;
    var cy2 = p.sy + (p.ty - p.sy) * ease + p.arcH * Math.sin(t * Math.PI); // parabola
    p.trail.push({x: cx2, y: cy2, a: 1});
    if (p.trail.length > 16) p.trail.shift();
    // Glowing trail
    for (var j = 1; j < p.trail.length; j++) {
      var ta = (j / p.trail.length);
      crossCtx.save(); crossCtx.globalAlpha = ta * 0.5;
      crossCtx.strokeStyle = p.color; crossCtx.lineWidth = p.size * ta * 0.7;
      crossCtx.lineCap = 'round'; crossCtx.beginPath();
      crossCtx.moveTo(p.trail[j-1].x, p.trail[j-1].y);
      crossCtx.lineTo(p.trail[j].x, p.trail[j].y);
      crossCtx.stroke(); crossCtx.restore();
    }
    // White core trail
    for (var j = Math.max(1, p.trail.length-5); j < p.trail.length; j++) {
      var ta = ((j - p.trail.length + 6) / 6);
      crossCtx.save(); crossCtx.globalAlpha = ta * 0.7;
      crossCtx.strokeStyle = '#fff'; crossCtx.lineWidth = Math.max(1, p.size * ta * 0.3);
      crossCtx.lineCap = 'round'; crossCtx.beginPath();
      crossCtx.moveTo(p.trail[j-1].x, p.trail[j-1].y);
      crossCtx.lineTo(p.trail[j].x, p.trail[j].y);
      crossCtx.stroke(); crossCtx.restore();
    }
    // Head glow
    crossCtx.save();
    var hg = crossCtx.createRadialGradient(cx2, cy2, 0, cx2, cy2, p.size * 2.5);
    hg.addColorStop(0, 'rgba(255,255,255,0.4)'); hg.addColorStop(0.4, p.color); hg.addColorStop(1, 'rgba(0,0,0,0)');
    crossCtx.globalAlpha = 0.6; crossCtx.fillStyle = hg;
    crossCtx.beginPath(); crossCtx.arc(cx2, cy2, p.size * 2.5, 0, T2); crossCtx.fill();
    // Bright core
    crossCtx.globalAlpha = 0.95; crossCtx.fillStyle = '#fff';
    crossCtx.beginPath(); crossCtx.arc(cx2, cy2, p.size * 0.5, 0, T2); crossCtx.fill();
    crossCtx.restore();
  }
}
function showOppAtkBadge(power) {
  const el = document.getElementById('opp-atk-badge');
  if (!el) return;
  el.textContent = '\u2694 +' + power;
  el.classList.add('visible');
  clearTimeout(el._timer);
  el._timer = setTimeout(function() { el.classList.remove('visible'); }, 1800);
}

// ═══ DRAWING ═══
function pathChamferRect(c, x, y, w, h, cut) {
  cut = Math.max(0, Math.min(cut || 0, Math.floor(Math.min(w, h) * 0.45)));
  c.beginPath();
  if (cut < 1) { c.rect(x, y, w, h); return; }
  c.moveTo(x + cut, y);
  c.lineTo(x + w - cut, y);
  c.lineTo(x + w, y + cut);
  c.lineTo(x + w, y + h - cut);
  c.lineTo(x + w - cut, y + h);
  c.lineTo(x + cut, y + h);
  c.lineTo(x, y + h - cut);
  c.lineTo(x, y + cut);
  c.closePath();
}
function fillChamferRect(c, x, y, w, h, cut) { pathChamferRect(c, x, y, w, h, cut); c.fill(); }
function strokeChamferRect(c, x, y, w, h, cut) { pathChamferRect(c, x, y, w, h, cut); c.stroke(); }
function pathRoundRect(c, x, y, w, h, r) {
  r = Math.max(0, Math.min(r || 0, Math.min(w, h) * 0.5));
  c.beginPath();
  if (r < 1) { c.rect(x, y, w, h); return; }
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.quadraticCurveTo(x + w, y, x + w, y + r);
  c.lineTo(x + w, y + h - r);
  c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  c.lineTo(x + r, y + h);
  c.quadraticCurveTo(x, y + h, x, y + h - r);
  c.lineTo(x, y + r);
  c.quadraticCurveTo(x, y, x + r, y);
  c.closePath();
}
function fillRoundRect(c, x, y, w, h, r) { pathRoundRect(c, x, y, w, h, r); c.fill(); }
function strokeRoundRect(c, x, y, w, h, r) { pathRoundRect(c, x, y, w, h, r); c.stroke(); }
function mixRgb(a, b, t) {
  t = Math.max(0, Math.min(1, t || 0));
  return [
    Math.round(a[0] + (b[0] - a[0]) * t),
    Math.round(a[1] + (b[1] - a[1]) * t),
    Math.round(a[2] + (b[2] - a[2]) * t)
  ];
}
function rgbaRgb(rgb, a) { return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + a + ')'; }

function drawCell(c, x, y, lv, sz, al) {
  if (sz === undefined) sz = CELL;
  if (al === undefined) al = 1;
  if (lv === 0) return;
  var cx = x + sz / 2, cy = y + sz / 2;
  var rad = sz * 0.42;
  c.save(); c.globalAlpha *= al;

  if (lv === JUNK) {
    // Frosted gray junk block
    c.fillStyle = 'rgba(100,120,140,0.12)';
    c.beginPath(); c.arc(cx, cy + 1.2, rad, 0, Math.PI * 2); c.fill();
    var jg = c.createRadialGradient(cx - rad * 0.25, cy - rad * 0.25, rad * 0.1, cx, cy, rad);
    jg.addColorStop(0, 'rgba(160,175,195,.7)');
    jg.addColorStop(0.7, 'rgba(130,148,170,.65)');
    jg.addColorStop(1, 'rgba(110,128,150,.6)');
    c.fillStyle = jg;
    c.beginPath(); c.arc(cx, cy, rad, 0, Math.PI * 2); c.fill();
    // Subtle cross-hatch
    c.save(); c.beginPath(); c.arc(cx, cy, rad, 0, Math.PI * 2); c.clip();
    c.strokeStyle = 'rgba(255,255,255,0.2)'; c.lineWidth = 1;
    var stripeGap = sz <= 20 ? 5 : 6;
    for (var i = -sz; i < sz * 2; i += stripeGap) {
      c.beginPath(); c.moveTo(x + i, y + sz); c.lineTo(x + i + sz, y); c.stroke();
    }
    c.restore();
    // Specular
    c.fillStyle = 'rgba(255,255,255,0.18)';
    c.beginPath(); c.ellipse(cx - rad * 0.2, cy - rad * 0.3, rad * 0.3, rad * 0.18, -0.4, 0, Math.PI * 2); c.fill();
    // Question mark
    c.fillStyle = 'rgba(255,255,255,' + (0.85 * al) + ')';
    c.font = Math.floor(sz * 0.36) + 'px LilitaOne, Outfit, sans-serif';
    c.textAlign = 'center'; c.textBaseline = 'middle';
    c.strokeStyle = 'rgba(90,110,130,0.5)'; c.lineWidth = Math.max(1, sz * 0.06);
    c.strokeText('?', cx, cy + 1);
    c.fillText('?', cx, cy + 1);
    c.restore(); return;
  }

  // Level 6+: about to ACTUALLY explode — white-hot strobe
  if (lv > MAX_LEVEL) {
    var rad6 = sz * 0.42;
    var t6 = Date.now();
    var strobe = Math.sin(t6 * 0.025) * 0.5 + 0.5;
    var fastFlicker = Math.sin(t6 * 0.06) * 0.3 + 0.7;
    c.shadowColor = 'rgba(77,184,217,.6)'; c.shadowBlur = 16 + strobe * 10;
    // Bright core
    c.fillStyle = 'rgb('+(200+Math.floor(strobe*55))+','+(230+Math.floor(strobe*25))+','+(240+Math.floor(strobe*15))+')';
    c.beginPath(); c.arc(cx, cy, rad6, 0, Math.PI * 2); c.fill();
    // Bright inner glow overlay
    var g6 = c.createRadialGradient(cx, cy, 0, cx, cy, rad6);
    g6.addColorStop(0, 'rgba(255,255,255,' + 0.5 * fastFlicker + ')'); g6.addColorStop(1, 'rgba(77,184,217,0)');
    c.fillStyle = g6; c.beginPath(); c.arc(cx, cy, rad6, 0, Math.PI * 2); c.fill();
    // Pulsing border
    c.strokeStyle = 'rgba(77,184,217,' + (0.7 + strobe * 0.3) + ')'; c.lineWidth = 2.5;
    c.beginPath(); c.arc(cx, cy, rad6 + 1, 0, Math.PI * 2); c.stroke();
    c.shadowColor = 'transparent'; c.shadowBlur = 0;
    // Exclamation mark
    c.fillStyle = 'rgba(255,255,255,' + fastFlicker + ')'; c.font = 'bold ' + Math.floor(sz * 0.4) + 'px LilitaOne, Outfit, sans-serif'; c.textAlign = 'center'; c.textBaseline = 'middle'; c.fillText('\u2716', cx, cy);
    c.restore(); return;
  }

  var v = Math.min(lv, MAX_LEVEL);
  var rgb = COLOR_RGB[v] || [180, 180, 180];
  var darkRgb = mixRgb(rgb, [80, 120, 160], 0.45);
  var topRgb = mixRgb(rgb, [140, 190, 230], 0.22);
  var iceRgb = mixRgb(rgb, [230, 245, 255], 0.45);
  var fogRgb = mixRgb(rgb, [250, 253, 255], 0.7);
  var rimRgb = mixRgb(rgb, [255, 255, 255], 0.65);
  var px = x + sz * 0.06, py = y + sz * 0.06;
  var pw = sz * 0.88, ph = sz * 0.88;
  var rr = Math.max(2, sz * 0.18);
  var seamX = px + pw * 0.5;
  var smallCell = sz <= 20;

  // Outer glow for high levels
  if (v === 5) {
    var pulse5 = Math.sin(Date.now() * 0.008);
    c.shadowColor = COLORS[v]; c.shadowBlur = 17 + pulse5 * 5;
  } else if (v >= 3) { c.shadowColor = COLORS[v]; c.shadowBlur = v === 4 ? 10 : 7; }

  // Soft contact shadow under the cube.
  c.fillStyle = 'rgba(80,120,160,0.12)';
  c.beginPath(); c.ellipse(cx, y + sz * 0.9, sz * 0.33, sz * 0.11, 0, 0, Math.PI * 2); c.fill();

  c.save();
  pathRoundRect(c, px, py, pw, ph, rr);
  c.clip();

  // Main translucent body
  var faceGrad = c.createLinearGradient(px, py, px, py + ph);
  faceGrad.addColorStop(0, rgbaRgb(mixRgb(topRgb, [255, 255, 255], 0.08), 0.98));
  faceGrad.addColorStop(0.22, rgbaRgb(mixRgb(rgb, [255, 255, 255], 0.06), 0.95));
  faceGrad.addColorStop(0.58, rgbaRgb(iceRgb, 0.9));
  faceGrad.addColorStop(1, rgbaRgb(fogRgb, 0.95));
  c.fillStyle = faceGrad;
  c.fillRect(px - 1, py - 1, pw + 2, ph + 2);

  // Darker top cap from the video reference
  var topCap = c.createLinearGradient(px, py, px, py + ph * 0.34);
  topCap.addColorStop(0, rgbaRgb(mixRgb(darkRgb, rgb, 0.22), 0.92));
  topCap.addColorStop(0.5, rgbaRgb(topRgb, 0.72));
  topCap.addColorStop(1, 'rgba(255,255,255,0)');
  c.fillStyle = topCap;
  c.fillRect(px - 1, py - 1, pw + 2, ph * 0.38);

  // Side volume shading for a cube-like read
  var leftShade = c.createLinearGradient(px, py, px + pw * 0.5, py);
  leftShade.addColorStop(0, rgbaRgb(darkRgb, 0.36));
  leftShade.addColorStop(0.45, rgbaRgb(mixRgb(darkRgb, iceRgb, 0.45), 0.12));
  leftShade.addColorStop(1, 'rgba(0,0,0,0)');
  c.fillStyle = leftShade;
  c.fillRect(px - 1, py, pw * 0.56, ph);

  var rightShade = c.createLinearGradient(px + pw, py, px + pw * 0.45, py);
  rightShade.addColorStop(0, rgbaRgb(darkRgb, 0.3));
  rightShade.addColorStop(0.55, rgbaRgb(mixRgb(darkRgb, iceRgb, 0.52), 0.08));
  rightShade.addColorStop(1, 'rgba(0,0,0,0)');
  c.fillStyle = rightShade;
  c.fillRect(px + pw * 0.44, py, pw * 0.57 + 1, ph);

  // Milky ice fog in the lower body
  var fogGrad = c.createLinearGradient(px, py + ph * 0.42, px, py + ph);
  fogGrad.addColorStop(0, 'rgba(255,255,255,0)');
  fogGrad.addColorStop(0.55, rgbaRgb(mixRgb(iceRgb, [255, 255, 255], 0.4), 0.18));
  fogGrad.addColorStop(1, rgbaRgb(fogRgb, 0.72));
  c.fillStyle = fogGrad;
  c.fillRect(px, py + ph * 0.34, pw, ph * 0.7);

  // Internal seam / prism lines
  c.lineCap = 'round';
  c.strokeStyle = 'rgba(255,255,255,0.34)';
  c.lineWidth = Math.max(1, sz * 0.04);
  c.beginPath();
  c.moveTo(seamX, py + ph * 0.12);
  c.lineTo(seamX, py + ph * 0.94);
  c.stroke();

  c.strokeStyle = 'rgba(255,255,255,0.16)';
  c.lineWidth = Math.max(1, sz * 0.028);
  c.beginPath();
  c.moveTo(seamX, py + ph * 0.77);
  c.lineTo(px + pw * 0.14, py + ph * 0.95);
  c.moveTo(seamX, py + ph * 0.77);
  c.lineTo(px + pw * 0.86, py + ph * 0.95);
  c.stroke();

  // Top-surface liquid highlights
  c.fillStyle = 'rgba(255,255,255,0.26)';
  c.beginPath();
  c.moveTo(px + pw * 0.12, py + ph * 0.2);
  c.bezierCurveTo(px + pw * 0.24, py + ph * 0.08, px + pw * 0.42, py + ph * 0.1, px + pw * 0.55, py + ph * 0.2);
  c.bezierCurveTo(px + pw * 0.42, py + ph * 0.27, px + pw * 0.24, py + ph * 0.27, px + pw * 0.12, py + ph * 0.2);
  c.closePath();
  c.fill();

  c.fillStyle = 'rgba(255,255,255,0.18)';
  c.beginPath();
  c.moveTo(px + pw * 0.58, py + ph * 0.16);
  c.bezierCurveTo(px + pw * 0.68, py + ph * 0.07, px + pw * 0.83, py + ph * 0.09, px + pw * 0.9, py + ph * 0.18);
  c.bezierCurveTo(px + pw * 0.82, py + ph * 0.25, px + pw * 0.68, py + ph * 0.25, px + pw * 0.58, py + ph * 0.16);
  c.closePath();
  c.fill();

  if (!smallCell) {
    c.strokeStyle = 'rgba(255,255,255,0.24)';
    c.lineWidth = Math.max(1, sz * 0.022);
    c.beginPath();
    c.moveTo(px + pw * 0.16, py + ph * 0.22);
    c.quadraticCurveTo(seamX, py + ph * 0.02, px + pw * 0.84, py + ph * 0.22);
    c.stroke();

    c.fillStyle = 'rgba(255,255,255,0.12)';
    c.beginPath();
    c.moveTo(px + pw * 0.16, py + ph * 0.78);
    c.quadraticCurveTo(seamX, py + ph * 0.59, px + pw * 0.84, py + ph * 0.78);
    c.lineTo(px + pw * 0.8, py + ph * 0.96);
    c.quadraticCurveTo(seamX, py + ph * 0.84, px + pw * 0.2, py + ph * 0.96);
    c.closePath();
    c.fill();
  }

  // Front glossy strip
  var gloss = c.createLinearGradient(px, py + ph * 0.2, px, py + ph * 0.48);
  gloss.addColorStop(0, 'rgba(255,255,255,0.22)');
  gloss.addColorStop(1, 'rgba(255,255,255,0)');
  c.fillStyle = gloss;
  c.fillRect(px + pw * 0.06, py + ph * 0.2, pw * 0.88, ph * 0.32);

  // ── Frost / ice crystal overlay ──
  // Edge frost (thick icy rim)
  var frostEdge = c.createRadialGradient(cx, cy, rad * 0.35, cx, cy, rad * 1.15);
  frostEdge.addColorStop(0, 'rgba(255,255,255,0)');
  frostEdge.addColorStop(0.45, 'rgba(230,245,255,0)');
  frostEdge.addColorStop(0.7, 'rgba(220,240,255,0.18)');
  frostEdge.addColorStop(0.85, 'rgba(210,235,250,0.32)');
  frostEdge.addColorStop(1, 'rgba(200,230,248,0.45)');
  c.fillStyle = frostEdge;
  c.fillRect(px - 1, py - 1, pw + 2, ph + 2);
  // Frosty mist over lower half
  var frostMist = c.createLinearGradient(px, py + ph * 0.4, px, py + ph);
  frostMist.addColorStop(0, 'rgba(255,255,255,0)');
  frostMist.addColorStop(0.6, 'rgba(225,242,255,0.08)');
  frostMist.addColorStop(1, 'rgba(215,238,252,0.18)');
  c.fillStyle = frostMist;
  c.fillRect(px, py + ph * 0.4, pw, ph * 0.6);
  // Ice crystal flecks (larger, more visible)
  if (!smallCell) {
    var fx = px * 7.3 + py * 3.1;
    for (var fi = 0; fi < 6; fi++) {
      var fa = Math.sin(fx + fi * 47.1) * Math.PI;
      var fd = 0.15 + Math.abs(Math.sin(fx + fi * 23.7)) * 0.32;
      var fcx2 = cx + Math.cos(fa) * pw * fd;
      var fcy2 = cy + Math.sin(fa) * ph * fd;
      var fLen = sz * 0.09 + Math.abs(Math.cos(fx + fi * 13.3)) * sz * 0.09;
      c.save();
      c.translate(fcx2, fcy2);
      c.rotate(fa);
      c.fillStyle = 'rgba(255,255,255,0.22)';
      // Six-pointed star crystal
      for (var arm = 0; arm < 3; arm++) {
        c.fillRect(-fLen, -0.5, fLen * 2, 1);
        // Small branch nubs
        c.fillRect(-fLen * 0.6, -fLen * 0.25, 0.8, fLen * 0.5);
        c.fillRect(fLen * 0.4, -fLen * 0.2, 0.8, fLen * 0.4);
        c.rotate(Math.PI / 3);
      }
      c.restore();
    }
  }

  c.restore();
  c.shadowColor = 'transparent'; c.shadowBlur = 0;

  // Rim highlight
  c.strokeStyle = rgbaRgb(rimRgb, 0.34);
  c.lineWidth = Math.max(1, sz * 0.04);
  strokeRoundRect(c, px + 0.5, py + 0.5, pw - 1, ph - 1, Math.max(1, rr - 0.5));
  c.strokeStyle = 'rgba(255,255,255,0.16)';
  c.lineWidth = Math.max(0.8, sz * 0.02);
  c.beginPath();
  c.moveTo(px + rr * 0.9, py + 1);
  c.lineTo(px + pw - rr * 0.9, py + 1);
  c.stroke();

  // Level 5: pulsing glow border
  if (v === 5) {
    var borderPulse = 0.5 + Math.sin(Date.now() * 0.006 + 1.5) * 0.3;
    c.strokeStyle = 'rgba(240,208,128,' + borderPulse + ')'; c.lineWidth = 1.5;
    strokeRoundRect(c, px, py, pw, ph, rr);
  }

  // Level number
  c.fillStyle = 'rgba(255,255,255,0.92)';
  c.font = Math.floor(sz * (smallCell ? 0.3 : 0.34)) + 'px LilitaOne, Outfit, sans-serif';
  c.textAlign = 'center'; c.textBaseline = 'middle';
  c.strokeStyle = rgbaRgb(mixRgb(darkRgb, [60, 90, 120], 0.35), 0.45);
  c.lineWidth = Math.max(1.4, sz * 0.065);
  c.strokeText(v, cx, cy + sz * 0.06);
  c.fillText(v, cx, cy + sz * 0.06);
  c.restore();
}
// ═══ FROST NOISE CACHE ═══
var frostNoiseCanvas = null;
function buildFrostNoiseCache() {
  frostNoiseCanvas = document.createElement('canvas');
  frostNoiseCanvas.width = BOARD_W; frostNoiseCanvas.height = BOARD_H;
  var fc = frostNoiseCanvas.getContext('2d');
  fc.globalAlpha = 0.09;
  for (var fy = 0; fy < BOARD_H; fy += 12) { for (var fx = 0; fx < BOARD_W; fx += 12) {
    var fn = Math.sin(fx * 12.9898 + fy * 78.233) * 43758.5453; fn = fn - Math.floor(fn);
    if (fn > 0.45) { fc.fillStyle = 'rgba(255,255,255,' + fn * 0.6 + ')'; fc.fillRect(fx + fn * 3, fy + fn * 2, 1.5 + fn * 3, 0.5 + fn * 1.5); }
  }}
}
buildFrostNoiseCache();
function draw() {
  var sx = 0, sy = 0, sr = 0;
  var nowMs = frameNowMs || (typeof performance !== 'undefined' ? performance.now() : Date.now());
  if (shakeAmount > 0.2) {
    var tNoise = (nowMs % 100000) * 0.03;
    sx = (Math.random()-.5)*shakeAmount*0.55 + Math.sin(tNoise*1.4)*shakeAmount*0.18 + shakeBiasX*0.18;
    sy = (Math.random()-.5)*shakeAmount*0.55 + Math.cos(tNoise*1.9)*shakeAmount*0.16 + shakeBiasY*0.18;
    sr = (Math.random()-.5) * 0.0018 * shakeAmount + shakeRot;
    shakeAmount *= 0.87; shakeBiasX *= 0.82; shakeBiasY *= 0.82; shakeRot *= 0.74;
    if (shakeAmount < 0.2) { shakeAmount = 0; shakeBiasX = 0; shakeBiasY = 0; shakeRot = 0; }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(PAD+sx, PAD+sy); if (sr) { ctx.translate(BOARD_W/2, BOARD_H/2); ctx.rotate(sr); ctx.translate(-BOARD_W/2, -BOARD_H/2); }
  ctx.fillStyle = 'rgba(180,215,240,.55)'; ctx.fillRect(0,0,BOARD_W,BOARD_H);
  // ── Frost / ice glass overlay ──
  // Full-board frosty fog (gentle white mist)
  ctx.fillStyle='rgba(220,240,252,0.13)'; ctx.fillRect(0,0,BOARD_W,BOARD_H);
  // Edge frost vignette — wide, strong
  var fvL = ctx.createLinearGradient(0,0,BOARD_W*0.32,0);
  fvL.addColorStop(0,'rgba(210,235,250,0.45)'); fvL.addColorStop(0.5,'rgba(220,240,255,0.18)'); fvL.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=fvL; ctx.fillRect(0,0,BOARD_W*0.32,BOARD_H);
  var fvR = ctx.createLinearGradient(BOARD_W,0,BOARD_W*0.68,0);
  fvR.addColorStop(0,'rgba(210,235,250,0.45)'); fvR.addColorStop(0.5,'rgba(220,240,255,0.18)'); fvR.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=fvR; ctx.fillRect(BOARD_W*0.68,0,BOARD_W*0.32,BOARD_H);
  var fvT = ctx.createLinearGradient(0,0,0,BOARD_H*0.18);
  fvT.addColorStop(0,'rgba(215,238,252,0.5)'); fvT.addColorStop(0.5,'rgba(225,242,255,0.2)'); fvT.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=fvT; ctx.fillRect(0,0,BOARD_W,BOARD_H*0.18);
  var fvB = ctx.createLinearGradient(0,BOARD_H,0,BOARD_H*0.85);
  fvB.addColorStop(0,'rgba(215,238,252,0.4)'); fvB.addColorStop(0.5,'rgba(225,242,255,0.15)'); fvB.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=fvB; ctx.fillRect(0,BOARD_H*0.85,BOARD_W,BOARD_H*0.15);
  // Corner frost blobs (thickest frost accumulates in corners)
  var corners=[[0,0],[BOARD_W,0],[0,BOARD_H],[BOARD_W,BOARD_H]];
  for(var ci=0;ci<4;ci++){var co=corners[ci];
    var cg=ctx.createRadialGradient(co[0],co[1],0,co[0],co[1],BOARD_W*0.35);
    cg.addColorStop(0,'rgba(215,238,252,0.35)');cg.addColorStop(0.4,'rgba(225,242,255,0.12)');cg.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=cg;ctx.fillRect(0,0,BOARD_W,BOARD_H);
  }
  // Frosted noise texture (cached)
  if (frostNoiseCanvas) { ctx.drawImage(frostNoiseCanvas, 0, 0); }
  if (screenFlash > 0.01) {
    var fr = screenFlashColor[0], fg = screenFlashColor[1], fb = screenFlashColor[2];
    var fcx = screenFlashFocusX - PAD, fcy = screenFlashFocusY - PAD;
    var fgRad = ctx.createRadialGradient(fcx, fcy, 6, fcx, fcy, Math.max(BOARD_W, BOARD_H) * 0.78);
    fgRad.addColorStop(0, 'rgba('+fr+','+fg+','+fb+','+(screenFlash*0.95)+')');
    fgRad.addColorStop(0.35, 'rgba('+fr+','+fg+','+fb+','+(screenFlash*0.34)+')');
    fgRad.addColorStop(1, 'rgba('+fr+','+fg+','+fb+',0)');
    ctx.save();
    ctx.beginPath(); ctx.rect(0,0,BOARD_W,BOARD_H); ctx.clip();
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = fgRad; ctx.fillRect(0,0,BOARD_W,BOARD_H);
    if (screenFlash > 0.12) {
      ctx.strokeStyle = 'rgba(255,255,255,'+(screenFlash*0.75)+')';
      ctx.lineWidth = 2 + screenFlash * 4;
      ctx.beginPath();
      ctx.moveTo(fcx - 22, fcy); ctx.lineTo(fcx + 22, fcy);
      ctx.moveTo(fcx, fcy - 22); ctx.lineTo(fcx, fcy + 22);
      ctx.stroke();
    }
    ctx.restore();
    screenFlash *= 0.84; if(screenFlash<0.01) screenFlash=0;
  }
  if (boardPulse > 0.01) {
    var br = boardPulseColor[0], bg = boardPulseColor[1], bb = boardPulseColor[2];
    var bp = ctx.createRadialGradient(boardPulseX, boardPulseY, 4, boardPulseX, boardPulseY, Math.max(BOARD_W, BOARD_H) * 0.78);
    bp.addColorStop(0, 'rgba('+br+','+bg+','+bb+','+(boardPulse*0.45)+')');
    bp.addColorStop(0.45, 'rgba('+br+','+bg+','+bb+','+(boardPulse*0.16)+')');
    bp.addColorStop(1, 'rgba('+br+','+bg+','+bb+',0)');
    ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = bp; ctx.fillRect(0,0,BOARD_W,BOARD_H); ctx.restore();
    boardPulse *= 0.86; if (boardPulse < 0.01) boardPulse = 0;
  }
  ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.lineWidth = 1;
  for (var r = 0; r <= ROWS; r++) { ctx.beginPath(); ctx.moveTo(0,r*CELL); ctx.lineTo(BOARD_W,r*CELL); ctx.stroke(); }
  for (var c = 0; c <= COLS; c++) { ctx.beginPath(); ctx.moveTo(c*CELL,0); ctx.lineTo(c*CELL,BOARD_H); ctx.stroke(); }
  // Junk warnings
  var junkPulseBase = Math.sin(nowMs*0.006);
  for (var wi = 0; wi < warningJunkCols.length; wi++) {
    var col = warningJunkCols[wi];
    ctx.fillStyle = 'rgba(210,80,90,0.06)'; ctx.fillRect(col*CELL,0,CELL,BOARD_H);
    var pulse = 0.5 + junkPulseBase * 0.3;
    ctx.fillStyle = 'rgba(210,80,90,'+pulse+')'; ctx.font = 'bold 15px Outfit'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('\u26A0',col*CELL+CELL/2,12);
    var eg = ctx.createLinearGradient(col*CELL,0,col*CELL,CELL); eg.addColorStop(0,'rgba(210,80,90,'+(pulse*.28)+')'); eg.addColorStop(1,'rgba(210,80,90,0)'); ctx.fillStyle=eg; ctx.fillRect(col*CELL,0,CELL,CELL);
  }
  // Board cells
  if (gameState === 'heat' && preHeatBoard) {
    var tl = Math.min(heatAnimTimer/HEAT_DURATION,1), wY = tl*(BOARD_H+60)-30;
    for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) {
      var ol = preHeatBoard[r][c];
      if (ol === JUNK) drawCell(ctx,c*CELL,r*CELL,JUNK);
      else if (ol > 0) { var nl=board[r][c],cY=r*CELL+CELL/2,ct=Math.max(0,Math.min(1,(wY-cY+40)/80)); drawCell(ctx,c*CELL,r*CELL,ol,CELL,1-ct); drawCell(ctx,c*CELL,r*CELL,nl,CELL,ct); }
    }
    var hg = ctx.createLinearGradient(0,wY-40,0,wY+40); hg.addColorStop(0,'rgba(34,211,238,0)'); hg.addColorStop(0.5,'rgba(34,211,238,'+(0.18*Math.sin(tl*Math.PI))+')'); hg.addColorStop(1,'rgba(34,211,238,0)'); ctx.fillStyle=hg; ctx.fillRect(0,wY-40,BOARD_W,80);
    var pu = Math.sin(tl*Math.PI)*0.07; if(pu>0){ctx.fillStyle='rgba(34,211,238,'+pu+')';ctx.fillRect(0,0,BOARD_W,BOARD_H);}
  } else {
    for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) {
      if (board[r][c] === 0) continue;
      var k = r+','+c; var sc = cellScale[k] || 1;
      if (sc > 1) { sc -= 0.04; if(sc<=1){sc=1;delete cellScale[k];}else cellScale[k]=sc; }
      var j = cellJelly[k], jSx = 1, jSy = 1, jDx = 0, jDy = 0;
      if (j) {
        j.t += 1;
        j.amp *= 0.84;
        j.kickX *= 0.72;
        j.kickY *= 0.68;
        var jw = Math.sin(j.t * 0.72 + j.phase) * j.amp;
        var jPos = Math.max(0, jw), jNeg = Math.max(0, -jw);
        jSx = 1 + jPos * 0.18 - jNeg * 0.04;
        jSy = 1 - jPos * 0.24 + jNeg * 0.08;
        jDx = j.kickX + Math.sin(j.t * 0.51 + j.phase * 1.4) * CELL * 0.012 * j.amp;
        jDy = j.kickY + Math.cos(j.t * 0.64 + j.phase) * CELL * 0.008 * j.amp;
        if (j.amp < 0.03 && Math.abs(j.kickX) < 0.03 && Math.abs(j.kickY) < 0.03) { delete cellJelly[k]; j = null; }
      }
      var px = c*CELL+CELL/2, py = r*CELL+CELL/2;
      ctx.save(); ctx.translate(px + jDx,py + jDy); ctx.scale(sc * jSx,sc * jSy); ctx.translate(-px,-py);
      drawCell(ctx,c*CELL,r*CELL,board[r][c]===JUNK?JUNK:board[r][c]); ctx.restore();
      var fl = cellFlash[k]; if(fl&&fl.alpha>0){ctx.save();ctx.globalAlpha=Math.min(fl.alpha,1)*.6;ctx.fillStyle=fl.type==='white'?'#fff':'#4db8d9';ctx.beginPath();ctx.arc(c*CELL+CELL/2,r*CELL+CELL/2,CELL*0.42,0,Math.PI*2);ctx.fill();ctx.restore();fl.alpha-=0.05;if(fl.alpha<=0)delete cellFlash[k];}
      // Level 6+: intense sparks (about to explode)
      if(board[r][c]>MAX_LEVEL&&Math.random()<0.25){var spx=c*CELL+4+Math.random()*(CELL-8),spy=r*CELL+4+Math.random()*(CELL-8);particles.push({x:spx,y:spy,vx:(Math.random()-0.5)*1.5,vy:-1-Math.random()*2,life:0.5+Math.random()*0.4,decay:0.025,size:1.5+Math.random()*2.5,gravity:-0.02,r:200+Math.floor(Math.random()*55),g:240+Math.floor(Math.random()*15),b:245+Math.floor(Math.random()*10)});}
      // Level 5: gentle spark particles
      else if(board[r][c]===MAX_LEVEL&&Math.random()<0.06){var spx=c*CELL+4+Math.random()*(CELL-8),spy=r*CELL+4+Math.random()*(CELL-8);var _cr=COLOR_RGB[board[r][c]]||[180,180,180];particles.push({x:spx,y:spy,vx:(Math.random()-0.5)*0.6,vy:-0.5-Math.random()*1.2,life:0.4+Math.random()*0.3,decay:0.03,size:1+Math.random()*1.5,gravity:-0.01,r:_cr[0],g:_cr[1],b:_cr[2]});}
    }
  }
  // Ghost + current
  if (currentPiece && gameState === 'playing' && !gameOver) {
    var gr = currentPiece.row; while(canPlaceAt(currentPiece,gr+1,currentPiece.col)) gr++;
    if (gr !== currentPiece.row) for (var i = 0; i < currentPiece.cells.length; i++) { var r2=gr+currentPiece.cells[i][0],c2=currentPiece.col+currentPiece.cells[i][1]; drawCell(ctx,c2*CELL,r2*CELL,currentPiece.colors[i],CELL,0.18); }
    var minPc = Infinity, maxPc = -Infinity, minPr = Infinity, maxPr = -Infinity;
    for (var i = 0; i < currentPiece.cells.length; i++) {
      var rr2 = currentPiece.row + currentPiece.cells[i][0];
      var cc2 = currentPiece.col + currentPiece.cells[i][1];
      if (cc2 < minPc) minPc = cc2;
      if (cc2 > maxPc) maxPc = cc2;
      if (rr2 < minPr) minPr = rr2;
      if (rr2 > maxPr) maxPr = rr2;
    }
    var pieceCx = (minPc * CELL + (maxPc + 1) * CELL) * 0.5;
    var pieceCy = (minPr * CELL + (maxPr + 1) * CELL) * 0.5;
    var jellyTf = getCurrentPieceJellyTransform(currentPiece, nowMs);
    ctx.save();
    ctx.translate(pieceCx + jellyTf.x, pieceCy + jellyTf.y);
    if (jellyTf.rot) ctx.rotate(jellyTf.rot);
    ctx.scale(jellyTf.sx, jellyTf.sy);
    ctx.translate(-pieceCx, -pieceCy);
    for (var i = 0; i < currentPiece.cells.length; i++) {
      var r2 = currentPiece.row + currentPiece.cells[i][0], c2 = currentPiece.col + currentPiece.cells[i][1];
      if (r2 < 0) continue;
      var jx = Math.sin(nowMs * 0.075 + i * 1.7 + pieceJellyFx.wobblePhase) * CELL * 0.02 * pieceJellyFx.wobbleAmp;
      var jy = Math.cos(nowMs * 0.09 + i * 2.1 + pieceJellyFx.wobblePhase * 0.7) * CELL * 0.015 * pieceJellyFx.wobbleAmp;
      drawCell(ctx, c2*CELL + jx, r2*CELL + jy, currentPiece.colors[i]);
    }
    ctx.restore();
  }
  // Impact bursts (concentric water ripples)
  for (var i = impactBursts.length-1; i >= 0; i--) {
    var ib = impactBursts[i];
    ib.life -= ib.decay; ib.outer += ib.grow; ib.inner += ib.grow * 0.5;
    if (ib.life <= 0) { impactBursts.splice(i,1); continue; }
    if (ib.x < -PAD || ib.x > BOARD_W + PAD || ib.y < -PAD || ib.y > BOARD_H + PAD) { impactBursts.splice(i,1); continue; }
    ctx.save();
    ctx.translate(ib.x, ib.y);
    ctx.globalAlpha = Math.min(ib.life, 1);
    ctx.strokeStyle = 'rgba('+ib.r+','+ib.g+','+ib.b+','+(0.4 * ib.life)+')';
    ctx.lineWidth = Math.max(1, 2 * ib.life);
    ctx.beginPath(); ctx.arc(0, 0, ib.outer, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = 'rgba('+ib.r+','+ib.g+','+ib.b+','+(0.06 * ib.life)+')';
    ctx.beginPath(); ctx.arc(0, 0, ib.inner, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }
  // Water splash tick + draw
  splashTick();
  splashDraw(ctx);
  // Particles
  for (var i = particles.length-1; i >= 0; i--) {
    var p=particles[i];
    p.x += p.vx; p.y += p.vy;
    if (p.drag) { p.vx *= p.drag; p.vy *= p.drag; }
    p.vy += (p.gravity === undefined ? 0.08 : p.gravity);
    if (p.vr) p.rot = (p.rot || 0) + p.vr;
    p.life -= p.decay;
    if (p.life <= 0) { particles.splice(i,1); continue; }
    if (p.x < -PAD*1.4 || p.x > BOARD_W + PAD*1.4 || p.y < -PAD*1.6 || p.y > BOARD_H + PAD*1.8) { particles.splice(i,1); continue; }
    var palpha = Math.min(p.life,1);
    ctx.save();
    ctx.globalAlpha = palpha;
    if (p.shape === 'bubble') {
      var bsz = (p.size || 4) * Math.min(p.life * 1.2, 1);
      ctx.fillStyle = 'rgba('+p.r+','+p.g+','+p.b+','+(0.4 * palpha)+')';
      ctx.beginPath(); ctx.arc(p.x, p.y, bsz, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,'+(0.35 * palpha)+')';
      ctx.beginPath(); ctx.arc(p.x - bsz * 0.22, p.y - bsz * 0.25, bsz * 0.25, 0, Math.PI * 2); ctx.fill();
    } else if (p.shape === 'spark') {
      ctx.strokeStyle = 'rgb('+p.r+','+p.g+','+p.b+')';
      ctx.lineWidth = (p.width || 2) * Math.max(0.35, palpha);
      ctx.beginPath();
      ctx.moveTo(p.x - p.vx * (p.len || 6) * 0.28, p.y - p.vy * (p.len || 6) * 0.28);
      ctx.lineTo(p.x + p.vx * 0.15, p.y + p.vy * 0.15);
      ctx.stroke();
    } else if (p.shape === 'shard') {
      var dsz = (p.size || 3) * Math.max(0.55, palpha);
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot || Math.atan2(p.vy, p.vx));
      ctx.fillStyle = 'rgb('+p.r+','+p.g+','+p.b+')';
      ctx.beginPath(); ctx.arc(0, 0, dsz, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.fillStyle = 'rgb('+p.r+','+p.g+','+p.b+')';
      ctx.beginPath();
      ctx.arc(p.x,p.y,(p.size||3)*Math.min(p.life,1),0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
  // Rings
  for (var i = rings.length-1; i >= 0; i--) { var ri=rings[i];ri.radius+=ri.spd;ri.life-=0.03;if(ri.life<=0||ri.radius>ri.maxR||ri.x<-PAD||ri.x>BOARD_W+PAD||ri.y<-PAD||ri.y>BOARD_H+PAD){rings.splice(i,1);continue;} ctx.save();ctx.globalAlpha=ri.life*.55;ctx.strokeStyle=ri.color;ctx.lineWidth=2.5*ri.life;ctx.beginPath();ctx.arc(ri.x,ri.y,ri.radius,0,Math.PI*2);ctx.stroke();ctx.restore(); }
  // ── Water droplets v5 — cold bottle condensation ──
  wdUpdate();
  // Snapshot board for droplet refraction (before drawing drops)
  wdOffCtx.clearRect(0,0,BOARD_W,BOARD_H);
  wdOffCtx.drawImage(canvas,PAD,PAD,BOARD_W,BOARD_H,0,0,BOARD_W,BOARD_H);
  ctx.save();
  ctx.beginPath(); ctx.rect(0,0,BOARD_W,BOARD_H); ctx.clip();
  // 1. Dead trail streaks — variable-width wet channel
  for(var ti=0;ti<wdTrails.length;ti++){
    var tr=wdTrails[ti];
    if(tr.pts.length<3) continue;
    var ts=wdBuildTrailPoly(tr.pts,tr.w);
    if(!ts) continue;
    ctx.save();
    // Wet channel fill (slight transparency difference)
    ctx.globalAlpha=tr.alpha*0.55;
    ctx.fillStyle='rgba(210,235,255,0.28)';
    wdFillTrailPoly(ctx,ts); ctx.fill();
    // Edge highlights (wet border glint)
    ctx.globalAlpha=tr.alpha*0.35;
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth=0.4;
    ctx.beginPath();
    for(var k=0;k<ts.L.length;k++){if(k===0)ctx.moveTo(ts.L[k].x,ts.L[k].y);else ctx.lineTo(ts.L[k].x,ts.L[k].y);}
    ctx.stroke();
    ctx.beginPath();
    for(var k=0;k<ts.R.length;k++){if(k===0)ctx.moveTo(ts.R[k].x,ts.R[k].y);else ctx.lineTo(ts.R[k].x,ts.R[k].y);}
    ctx.stroke();
    ctx.restore();
  }
  // 2. Active sliding trails — variable-width wet channel with refraction
  for(var di=0;di<wdDrops.length;di++){
    var d=wdDrops[di];
    if(d.state!=='sliding'||d.path.length<4) continue;
    var ts=wdBuildTrailPoly(d.path,d.r*0.55);
    if(!ts) continue;
    ctx.save();
    // Clip to trail shape, draw refracted bg (slightly shifted = wet distortion)
    wdFillTrailPoly(ctx,ts); ctx.clip();
    ctx.drawImage(wdOffCanvas,0.6,0.4,BOARD_W,BOARD_H,0,0,BOARD_W,BOARD_H);
    ctx.fillStyle='rgba(255,255,255,0.04)';
    ctx.fillRect(0,0,BOARD_W,BOARD_H);
    ctx.restore();
    // Edge highlights along trail borders
    ctx.save();
    ctx.globalAlpha=0.1;
    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.lineWidth=0.4;
    ctx.beginPath();
    for(var k=0;k<ts.L.length;k++){if(k===0)ctx.moveTo(ts.L[k].x,ts.L[k].y);else ctx.lineTo(ts.L[k].x,ts.L[k].y);}
    ctx.stroke();
    ctx.beginPath();
    for(var k=0;k<ts.R.length;k++){if(k===0)ctx.moveTo(ts.R[k].x,ts.R[k].y);else ctx.lineTo(ts.R[k].x,ts.R[k].y);}
    ctx.stroke();
    ctx.restore();
  }
  // 3. Droplets with background refraction
  for(var di=0;di<wdDrops.length;di++){
    var d=wdDrops[di], dr=d.r;
    if(d.y+dr<-2||d.y-dr>BOARD_H+2) continue;
    wdDrawDrop(ctx, d.x, d.y, dr, d.state==='sliding'?d.vy:0, d.biasT);
  }
  ctx.restore();
  // Float texts (excluding combo-banner channel, drawn on overlay canvas)
  updateAndDrawFloatingTexts(floatingTexts, ctx);
  ctx.restore();
  drawComboBannerOverlay(sx, sy, sr);
}

function drawSide(context, piece, w, h) {
  context.clearRect(0,0,w,h); if(!piece) return;
  var cs=16, cells=piece.cells;
  var mc=0,mr=0; for(var i=0;i<cells.length;i++){if(cells[i][1]>mc)mc=cells[i][1];if(cells[i][0]>mr)mr=cells[i][0];}mc++;mr++;
  var ox=(w-mc*cs)/2, oy=(h-mr*cs)/2;
  for(var i=0;i<cells.length;i++) drawCell(context,ox+cells[i][1]*cs,oy+cells[i][0]*cs,piece.colors[i],cs);
}

// ═══ LOOP ═══
function gameLoop(ts) {
  if (!lastFrameTime) lastFrameTime = ts;
  frameNowMs = ts || 0;
  var dt = ts - lastFrameTime; lastFrameTime = ts;
  updatePieceJellyFx(dt);
  if (gameOver) {
    draw(); drawSide(nextCtx,nextPiece,60,60); drawSide(holdCtx,holdPiece,60,60);
    if (oppCtx && gameMode === 'versus') renderOpponentBoard();
    drawCrossCanvas();
    if(window._bgDropsDraw) window._bgDropsDraw();
    requestAnimationFrame(gameLoop); return;
  }
  if (paused || countdownActive) {
    lastFrameTime = ts;
    draw(); drawSide(nextCtx,nextPiece,60,60); drawSide(holdCtx,holdPiece,60,60);
    if (oppCtx && gameMode === 'versus') renderOpponentBoard();
    drawCrossCanvas();
    if(window._bgDropsDraw) window._bgDropsDraw();
    requestAnimationFrame(gameLoop); return;
  }
  if (hitstopTimer > 0) hitstopTimer -= dt;
  else switch (gameState) {
    case 'playing':
      dropTimer += dt;
      if (dropTimer >= getDropInterval()) {
        dropTimer = 0;
        if (currentPiece && canMove(currentPiece,1,0)) { currentPiece.row++; }
        else if (currentPiece) lockPiece(currentPiece);
      }
      break;
    case 'heat': updateHeat(dt); break;
    case 'resolve': updateResolve(dt); break;
  }
  draw(); drawSide(nextCtx,nextPiece,60,60); drawSide(holdCtx,holdPiece,60,60);
  if (oppCtx && gameMode === 'versus') renderOpponentBoard();
  drawCrossCanvas();
  if(window._bgDropsDraw) window._bgDropsDraw();
  requestAnimationFrame(gameLoop);
}

// ═══ INPUT ═══
function performAction(action, source) {
  if (action && typeof action === 'object') action = action.action || action.type;
  if (!action || gameOver || paused || countdownActive || gameState !== 'playing' || !currentPiece) return false;
  const beforePiece = { row: currentPiece.row, col: currentPiece.col, cells: JSON.stringify(currentPiece.cells), id: currentPiece.id };
  let attempted = true;
  switch (action) {
    case 'left':
      if (canMove(currentPiece,0,-1)) { currentPiece.col--; excitePieceJellyFx('move', 0.75); }
      break;
    case 'right':
      if (canMove(currentPiece,0,1)) { currentPiece.col++; excitePieceJellyFx('move', 0.75); }
      break;
    case 'down':
      if (canMove(currentPiece,1,0)) { currentPiece.row++; dropTimer = 0; }
      break;
    case 'rotR':
      rotateCW(currentPiece);
      excitePieceJellyFx('rotate', 0.85);
      break;
    case 'rotL':
      rotateCCW(currentPiece);
      excitePieceJellyFx('rotate', 0.85);
      break;
    case 'drop':  hardDrop(); break;
    case 'hold':  doHold(); break;
    default: attempted = false;
  }
  if (!attempted) return false;
  const changed = !currentPiece || beforePiece.id !== currentPiece.id || beforePiece.row !== currentPiece.row || beforePiece.col !== currentPiece.col || beforePiece.cells !== JSON.stringify(currentPiece.cells) || action === 'drop' || action === 'hold';
  emitColorChainEvent('input', { action, source: source||'local', changed, turn, gameState });
  return changed;
}

document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { togglePause(); return; }
  const keyMap = { ArrowLeft:'left', ArrowRight:'right', ArrowDown:'down', ArrowUp:'rotR', x:'rotR', X:'rotR', z:'rotL', Z:'rotL', c:'hold', C:'hold', ' ':'drop' };
  const action = keyMap[e.key]; if (!action) return;
  if (action === 'drop') e.preventDefault();
  performAction(action, 'local');
});

document.querySelectorAll('.touch-btn').forEach(function(b) {
  b.addEventListener('touchstart', function(e) { e.preventDefault(); performAction(b.dataset.action, 'touch'); });
});

// ═══ TAP-MOVE OVERLAY ═══
(function() {
  var tapOverlay = document.getElementById('tap-move-overlay');
  if (!tapOverlay) return;
  var lastTapTime = 0;
  tapOverlay.addEventListener('touchstart', function(e) {
    var now = Date.now();
    if (now - lastTapTime < 80) return;
    lastTapTime = now;
    var touch = e.touches[0];
    var rect = tapOverlay.getBoundingClientRect();
    var x = touch.clientX - rect.left;
    if (x < rect.width / 2) performAction('left', 'touch');
    else performAction('right', 'touch');
  });
  // Tap on pause overlay to resume
  var pauseOverlay = document.getElementById('pause-overlay');
  if (pauseOverlay) {
    pauseOverlay.addEventListener('click', function() { if (paused) togglePause(); });
  }
})();

// Resume button
document.getElementById('resume-btn').addEventListener('click', function() { if (paused) togglePause(); });

document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('rematch-btn').addEventListener('click', function() { requestQueueJoin(); });

// ═══ START ═══
function startGame(options) {
  if (options && typeof options.preventDefault === 'function') options = {};
  options = options || {};
  if (Object.prototype.hasOwnProperty.call(options, 'mode')) setGameMode(options.mode, options.matchRuntime || options);
  if (Object.prototype.hasOwnProperty.call(options, 'locale')) setLocale(options.locale, true);
  if (Object.prototype.hasOwnProperty.call(options, 'seed')) setGameplaySeed(options.seed);
  else if (gameMode === 'versus') setGameplaySeed(Date.now());
  else setGameplaySeed(null);

  initBoard(); score=0; turn=0; gameOver=false; gameState='playing';
  dropTimer=0; comboCount=0; hitstopTimer=0;
  lastCoinsMilestone=0; paused=false; countdownActive=false;
  holdPiece=null; holdUsedThisTurn=false;
  particles=[]; floatingTexts=[]; comboBannerTexts=[]; rings=[]; impactBursts=[];
  splashDrops=[]; splashDiscs=[]; splashRings=[]; comboParticles=[]; crossImpacts=[];
  if (comboBannerCtx && comboBannerCanvasEl) comboBannerCtx.clearRect(0,0,comboBannerCanvasEl.width,comboBannerCanvasEl.height);
  cellFlash={}; cellScale={}; cellJelly={}; activeCells=new Set();
  shakeAmount=0; shakeBiasX=0; shakeBiasY=0; shakeRot=0; screenFlash=0; preHeatBoard=null;
  boardPulse=0; screenFlashColor=[34,211,238]; boardPulseColor=[103,232,249];
  screenFlashFocusX = PAD + BOARD_W / 2; screenFlashFocusY = PAD + BOARD_H / 2;
  boardPulseX = BOARD_W / 2; boardPulseY = BOARD_H / 2;
  pendingJunkCols=[]; warningJunkCols=[];
  opponentBoard = null; crossProjectiles = [];
  renderOpponentBoard._logged = false;
  const _oppAtkBadge = document.getElementById('opp-atk-badge');
  if (_oppAtkBadge) _oppAtkBadge.classList.remove('visible');
  updateScoreUI(); updateTurnUI();
  var _cdReset=document.getElementById('combo-display');_cdReset.textContent='';_cdReset.className='';_cdReset.style.background='';_cdReset.style.webkitBackgroundClip='';_cdReset.style.backgroundClip='';_cdReset.style.color='';_cdReset.style.textShadow='';_cdReset.style.animation='';
  document.getElementById('heat-bar-fill').style.width='0%';
  const overlay = document.getElementById('game-over-overlay');
  if (overlay) overlay.className = '';
  var pauseOv = document.getElementById('pause-overlay');
  if (pauseOv) pauseOv.classList.remove('show');
  var countdownOv = document.getElementById('countdown-overlay');
  if (countdownOv) countdownOv.classList.remove('show');
  updateJunkPreviewUi();
  // Reset opponent board display (in versus mode, keep the WAITING overlay shown)
  if (oppCtx) oppCtx.clearRect(0,0,216,432);
  const oppOverlay = document.getElementById('opp-overlay');
  if (oppOverlay && gameMode !== 'versus') oppOverlay.classList.remove('show');
  currentPiece=createPiece(); nextPiece=createPiece();
  resetPieceJellyFx(true);
  excitePieceJellyFx('spawn', 1.1);
  planNextJunk(); lastFrameTime=0;
  applyLocalization();
  emitColorChainEvent('gameStarted', { mode: gameMode, seed: gameplaySeed, roomId: matchRuntime.roomId, playerId: matchRuntime.playerId, snapshot: getStateSnapshot() });
}

document.getElementById('locale-select').addEventListener('change', function(e) { setLocale(e.target.value); });
document.getElementById('fx-intensity-select').addEventListener('change', function(e) { applyFxProfile(e.target.value); });

window.addEventListener('resize', resizeCrossCanvas);
initMatchPanel();
loadVolumePrefs();
applyFxProfile(detectInitialFxProfile(), true);
setLocale(detectInitialLocale(), true);
updateModeUI();
updateMatchPanelVisibility();
startGame();
requestAnimationFrame(gameLoop);

// Mute button
document.getElementById('mute-btn').addEventListener('click', function() { toggleMute(); });
// VS toggle button
document.getElementById('vs-toggle-btn').addEventListener('click', function() {
  playSfx('button');
  var panel = document.getElementById('match-panel');
  if (panel && panel.classList.contains('collapsed')) {
    panel.classList.remove('collapsed');
    if (!netClient.connected && !netClient.connecting && netClient.serverUrl) connectMatchSocket(false);
  } else if (panel) {
    if (!netClient.inMatch && !netClient.queued) panel.classList.add('collapsed');
  }
});

// ═══ FX SETTINGS PANEL ═══
(function(){
  var btn=document.getElementById('fx-settings-btn');
  var panel=document.getElementById('fx-settings-panel');
  var closeBtn=document.getElementById('pp-close');
  function toggle(open){panel.classList.toggle('open',open);}
  btn.addEventListener('click',function(){toggle(!panel.classList.contains('open'));});
  closeBtn.addEventListener('click',function(){toggle(false);});
  document.getElementById('pp-enabled').addEventListener('change',function(){ppSettings.enabled=this.checked;ppApply();});
  var sliders=[
    {id:'pp-contrast',key:'contrast',div:100,fmt:2},
    {id:'pp-sat',key:'saturate',div:100,fmt:2},
    {id:'pp-bright',key:'brightness',div:100,fmt:2},
    {id:'pp-hue',key:'hueRotate',div:1,fmt:0,suf:'°'},
    {id:'pp-vig',key:'vignette',div:100,fmt:2},
  ];
  sliders.forEach(function(s){
    var el=document.getElementById(s.id);
    var valEl=document.getElementById(s.id+'-val');
    el.addEventListener('input',function(){
      var v=parseFloat(el.value)/s.div;
      ppSettings[s.key]=v;
      valEl.textContent=(s.fmt?v.toFixed(s.fmt):v)+(s.suf||'');
      ppApply();
    });
  });
  // Volume slider
  var volSlider = document.getElementById('vol-slider');
  var volVal = document.getElementById('vol-slider-val');
  if (volSlider) {
    volSlider.value = Math.round(masterVolume * 100);
    volSlider.addEventListener('input', function() {
      masterVolume = clampNum(parseInt(volSlider.value, 10) / 100, 0, 1);
      if (volVal) volVal.textContent = Math.round(masterVolume * 100) + '%';
      saveVolumePrefs();
    });
  }
})();

// ═══ BACKGROUND WATER DROPLETS ═══
(function(){
  var bgC = document.getElementById('bg-drops-canvas');
  var bgX = bgC.getContext('2d');
  var bgD = [], BG_MAX = 40;
  function bgResize(){
    bgC.width = window.innerWidth;
    bgC.height = window.innerHeight;
    if(bgD.length===0) bgInit();
  }
  function bgMk(x,y,r){ return {x:x,y:y,r:r,vy:0,state:'static',age:0,seed:Math.random()*999}; }
  function bgInit(){
    bgD=[];
    var w=bgC.width, h=bgC.height;
    for(var i=0;i<20;i++) bgD.push(bgMk(Math.random()*w, Math.random()*h, 0.5+Math.random()*2));
    for(var i=0;i<5;i++) bgD.push(bgMk(Math.random()*w, Math.random()*h, 2+Math.random()*2.5));
  }
  function bgUpdate(){
    var w=bgC.width, h=bgC.height;
    if(bgD.length<BG_MAX&&Math.random()<0.02)
      bgD.push(bgMk(Math.random()*w, Math.random()*h, 0.4+Math.random()*0.8));
    for(var i=bgD.length-1;i>=0;i--){
      var d=bgD[i]; d.age++;
      if(d.state==='static'){
        d.r+=0.00015+Math.random()*0.0003;
        if(d.r<2&&d.age>900) d.r-=0.00015;
        if(d.r>=4.5){ d.state='sliding'; d.vy=0.005; }
      } else {
        var t=d.age*0.005;
        d.vy+=0.0015*(1+Math.max(0,-Math.sin(t+Math.sin(t)*0.5))*3)*(0.1+d.r*0.03);
        d.vy*=0.97;
        if(d.vy>0.12+d.r*0.025) d.vy=0.12+d.r*0.025;
        d.y+=d.vy;
      }
      if(d.r<0.3||d.y>h+10){bgD.splice(i,1);continue;}
      if(d.r>5.5) d.r=5.5;
    }
    // Merge
    for(var i=0;i<bgD.length;i++){
      for(var j=i+1;j<bgD.length;j++){
        var dx=bgD[i].x-bgD[j].x,dy=bgD[i].y-bgD[j].y;
        if(Math.sqrt(dx*dx+dy*dy)<(bgD[i].r+bgD[j].r)*0.55){
          var big=bgD[i].r>=bgD[j].r?bgD[i]:bgD[j], sm=bgD[i].r>=bgD[j].r?bgD[j]:bgD[i];
          big.r=Math.min(Math.sqrt(big.r*big.r+sm.r*sm.r),5.5);
          var idx=bgD.indexOf(sm);
          if(idx>=0){bgD.splice(idx,1);if(idx<=i)i--;if(idx<j)j--;}
        }
      }
    }
  }
  function bgDrawDrop(c,x,y,r){
    if(r<1){c.save();c.globalAlpha=0.18;c.fillStyle='rgba(255,255,255,0.5)';c.beginPath();c.arc(x,y,r,0,Math.PI*2);c.fill();c.restore();return;}
    c.save();
    // Glass body
    c.globalAlpha=0.1;
    c.fillStyle='rgba(220,240,255,0.3)';
    c.beginPath();c.arc(x,y,r,0,Math.PI*2);c.fill();
    // Edge shadow
    c.globalAlpha=1;
    var rim=c.createRadialGradient(x,y,r*0.4,x,y,r);
    rim.addColorStop(0,'rgba(0,0,0,0)');
    rim.addColorStop(0.65,'rgba(0,15,35,0.02)');
    rim.addColorStop(1,'rgba(0,15,35,0.1)');
    c.fillStyle=rim;c.beginPath();c.arc(x,y,r,0,Math.PI*2);c.fill();
    // Specular
    if(r>1.5){
      c.globalAlpha=0.4;
      var hlR=r*0.28,hlX=x-r*0.22,hlY=y-r*0.25;
      var hl=c.createRadialGradient(hlX,hlY,0,hlX,hlY,hlR);
      hl.addColorStop(0,'rgba(255,255,255,0.85)');
      hl.addColorStop(0.35,'rgba(255,255,255,0.2)');
      hl.addColorStop(1,'rgba(255,255,255,0)');
      c.fillStyle=hl;c.beginPath();c.arc(hlX,hlY,hlR,0,Math.PI*2);c.fill();
    }
    if(r>2.5){c.globalAlpha=0.6;c.fillStyle='#fff';c.beginPath();c.arc(x-r*0.15,y-r*0.35,Math.max(0.4,r*0.05),0,Math.PI*2);c.fill();}
    c.globalAlpha=0.07;c.strokeStyle='rgba(255,255,255,0.3)';c.lineWidth=0.3;
    c.beginPath();c.arc(x,y,r-0.2,0,Math.PI*2);c.stroke();
    c.restore();
  }
  function bgDraw(){
    bgX.clearRect(0,0,bgC.width,bgC.height);
    bgUpdate();
    for(var i=0;i<bgD.length;i++){
      var d=bgD[i];
      bgDrawDrop(bgX,d.x,d.y,d.r);
    }
  }
  bgResize();
  window.addEventListener('resize',bgResize);
  // Expose for game loop
  window._bgDropsDraw = bgDraw;
})();

// ═══ AUTO-SCALE ═══
(function(){
  var gc = document.getElementById('game-container');
  function fitScale(){
    gc.style.transform = 'none';
    var r = gc.getBoundingClientRect();
    var sx = window.innerWidth / r.width;
    var sy = window.innerHeight / r.height;
    var s = Math.min(sx, sy, 2) * 0.92;
    gc.style.transform = 'scale('+s+')';
  }
  fitScale();
  window.addEventListener('resize', fitScale);
})();
</script>
</body>
</html>
