<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>컬러 체인</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800;900&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0f;color:#fff;font-family:'Outfit',sans-serif;display:flex;justify-content:center;align-items:center;min-height:100vh;overflow:hidden}
#game-container{position:relative;display:flex;flex-direction:column;align-items:center;gap:10px}
#top-bar{display:flex;justify-content:space-between;align-items:center;width:100%;padding:0 4px}
#score-display{font-size:18px;font-weight:800;color:#ccc}
#score-display span{color:#ff6b4a;font-size:24px}
#combo-display{font-size:16px;font-weight:800;color:transparent;min-width:100px;text-align:right;transition:transform .15s}
#combo-display.active{color:#ffcc00;text-shadow:0 0 12px rgba(255,200,0,.6)}
#turn-display{font-size:13px;font-weight:600;color:#555}
#board-wrapper{position:relative;border:2px solid #1a1a2e;border-radius:8px;overflow:visible;background:transparent;width:216px;height:437px;box-shadow:0 0 40px rgba(100,50,255,.05)}
#board-bg{position:absolute;top:0;left:0;right:0;bottom:0;background:#0d0d18;border-radius:6px;z-index:1;overflow:hidden}
canvas#gameCanvas{display:block;margin:-60px;position:relative;z-index:10;pointer-events:none}
#heat-bar{width:100%;height:5px;background:#1a1a2e;overflow:hidden;position:relative;z-index:2}
#heat-bar-fill{height:100%;border-radius:0 2px 2px 0;transition:width .3s;background:linear-gradient(90deg,#3498db,#e67e22,#e74c3c);box-shadow:0 0 8px rgba(231,76,60,.3)}
#side-panels{position:absolute;top:0;right:-80px;display:flex;flex-direction:column;gap:12px;z-index:20}
.side-box{display:flex;flex-direction:column;align-items:center;gap:3px}
.side-label{font-size:9px;font-weight:600;color:#444;text-transform:uppercase;letter-spacing:2px}
.side-canvas{background:#0d0d18;border:1px solid #1a1a2e;border-radius:6px}
#controls-hint{font-size:10px;color:#333;text-align:center;line-height:1.8}
#game-over-overlay{display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.88);z-index:200;flex-direction:column;justify-content:center;align-items:center;gap:16px;border-radius:8px}
#game-over-overlay.show{display:flex}
#game-over-overlay h2{font-size:28px;font-weight:900;color:#ff4444;text-transform:uppercase;letter-spacing:4px}
#game-over-overlay .final-score{font-size:18px;color:#aaa}
#game-over-overlay .final-score span{color:#ff6b4a;font-weight:800;font-size:24px}
#restart-btn{margin-top:8px;padding:10px 32px;background:#ff6b4a;color:#fff;border:none;border-radius:6px;font-family:'Outfit',sans-serif;font-size:15px;font-weight:700;cursor:pointer;letter-spacing:1px}
#restart-btn:hover{background:#ff8566}
#touch-controls{display:none;width:100%;gap:6px;justify-content:center;padding-top:4px;flex-wrap:wrap}
.touch-btn{width:52px;height:52px;background:#1a1a2e;border:1px solid #2a2a4e;border-radius:10px;color:#888;font-size:18px;display:flex;align-items:center;justify-content:center;cursor:pointer;-webkit-tap-highlight-color:transparent;user-select:none}
.touch-btn:active{background:#2a2a4e}
.touch-btn.wide{width:64px;font-size:11px;font-weight:700;letter-spacing:1px}
@media(pointer:coarse){#touch-controls{display:flex}#controls-hint{display:none}}
</style>
</head>
<body>
<div id="game-container">
  <div id="top-bar">
    <div id="score-display">SCORE <span id="score">0</span></div>
    <div id="turn-display">TURN <span id="turn">0</span></div>
    <div id="combo-display"></div>
  </div>
  <div id="board-wrapper">
    <div id="board-bg"></div>
    <div id="heat-bar"><div id="heat-bar-fill" style="width:0%"></div></div>
    <canvas id="gameCanvas"></canvas>
    <div id="side-panels">
      <div class="side-box"><div class="side-label">Next</div><canvas id="next-canvas" class="side-canvas" width="60" height="60"></canvas></div>
      <div class="side-box"><div class="side-label">Hold</div><canvas id="hold-canvas" class="side-canvas" width="60" height="60"></canvas></div>
    </div>
    <div id="game-over-overlay"><h2>Game Over</h2><div class="final-score">SCORE <span id="final-score">0</span></div><button id="restart-btn">RETRY</button></div>
  </div>
  <div id="controls-hint">← → 이동 | Z X 회전 | ↓ 소프트드롭 | Space 하드드롭 | C 킵</div>
  <div id="touch-controls">
    <div class="touch-btn" data-action="left">◀</div>
    <div class="touch-btn" data-action="rotL">↺</div>
    <div class="touch-btn" data-action="down">▼</div>
    <div class="touch-btn" data-action="rotR">↻</div>
    <div class="touch-btn" data-action="right">▶</div>
    <div class="touch-btn wide" data-action="drop">DROP</div>
    <div class="touch-btn wide" data-action="hold">HOLD</div>
  </div>
</div>
<script>
// ═══ CONSTANTS ═══
const COLS = 6, ROWS = 12, CELL = 36, PAD = 60;
const BOARD_W = COLS * CELL, BOARD_H = ROWS * CELL;
const COLORS = [null, '#9b59b6', '#3498db', '#2ecc71', '#f1c40f', '#e74c3c'];
const COLOR_RGB = [null, [155,89,182], [52,152,219], [46,204,113], [241,196,15], [231,76,60]];
const MAX_LEVEL = 5, JUNK = -1;
const JUNK_COLOR = '#555566', JUNK_RGB = [85, 85, 102];
const HEAT_INTERVAL = 10, JUNK_START = 5, JUNK_BASE_INT = 3;
const RESOLVE_DELAY = 350, HEAT_DURATION = 700;
const DIRS = [[-1,0],[1,0],[0,-1],[0,1]];

// Shape templates
const SHAPES = [
  { cells: [[0,0]],             id: 'O1' },
  { cells: [[0,0],[0,1]],       id: 'I2' },
  { cells: [[0,0],[0,1],[0,2]], id: 'I3' },
  { cells: [[0,0],[1,0],[1,1]], id: 'L3' },
];
// FIX #1: proper weighted random
const SHAPE_WEIGHTS = [20, 25, 30, 25];
const SHAPE_WEIGHT_SUM = SHAPE_WEIGHTS.reduce((a, b) => a + b, 0);

// ═══ CANVAS ═══
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = BOARD_W + PAD * 2;
canvas.height = BOARD_H + PAD * 2;
const nextCtx = document.getElementById('next-canvas').getContext('2d');
const holdCtx = document.getElementById('hold-canvas').getContext('2d');

// ═══ STATE ═══
let board, score, turn, currentPiece, nextPiece, holdPiece, holdUsedThisTurn, gameOver;
let dropTimer, dropInterval = 800, lastFrameTime;
let gameState = 'playing', resolveTimer = 0;
let heatAnimTimer = 0, preHeatBoard = null;
let comboCount = 0, hitstopTimer = 0;
let activeCells = new Set();
let pendingJunkCols = [], warningJunkCols = [];
let particles = [], floatingTexts = [], rings = [];
let shakeAmount = 0, screenFlash = 0;
let cellFlash = {}, cellScale = {};

// ═══ BOARD ═══
function initBoard() {
  board = [];
  for (let r = 0; r < ROWS; r++) board.push(new Array(COLS).fill(0));
}

function randomLevel() {
  const w = [0, 40, 35, 25];
  let roll = Math.random() * 100;
  for (let i = 1; i <= 3; i++) { roll -= w[i]; if (roll <= 0) return i; }
  return 1;
}

// ═══ PIECES ═══
function createPiece() {
  let roll = Math.random() * SHAPE_WEIGHT_SUM;
  let idx = 0;
  for (let i = 0; i < SHAPE_WEIGHTS.length; i++) {
    roll -= SHAPE_WEIGHTS[i];
    if (roll <= 0) { idx = i; break; }
  }
  const tmpl = SHAPES[idx];
  return {
    cells: tmpl.cells.map(c => [...c]),
    colors: tmpl.cells.map(() => randomLevel()),
    row: 0,
    col: Math.floor(COLS / 2) - (idx >= 2 ? 1 : 0),
    id: tmpl.id,
  };
}

// FIX #3: reset rotation on hold swap
function getDefaultCells(id) {
  const t = SHAPES.find(s => s.id === id);
  return t ? t.cells.map(c => [...c]) : [[0,0]];
}
function getDefaultCol(id) {
  const i = SHAPES.findIndex(s => s.id === id);
  return Math.floor(COLS / 2) - (i >= 2 ? 1 : 0);
}

function tryRotate(piece, fn) {
  if (piece.cells.length === 1) return;
  const nc = piece.cells.map(fn);
  const mr = Math.min(...nc.map(s => s[0]));
  const mc = Math.min(...nc.map(s => s[1]));
  const norm = nc.map(([r, c]) => [r - mr, c - mc]);
  for (const [r, c] of norm) {
    const br = piece.row + r, bc = piece.col + c;
    if (bc < 0 || bc >= COLS || br >= ROWS) return;
    if (br >= 0 && board[br][bc] !== 0) return;
  }
  piece.cells = norm;
}
function rotateCW(p) { tryRotate(p, ([r, c]) => [c, -r]); }
function rotateCCW(p) { tryRotate(p, ([r, c]) => [-c, r]); }

function canMove(p, dr, dc) {
  for (const [sr, sc] of p.cells) {
    const nr = p.row + sr + dr, nc = p.col + sc + dc;
    if (nc < 0 || nc >= COLS || nr >= ROWS) return false;
    if (nr >= 0 && board[nr][nc] !== 0) return false;
  }
  return true;
}
function canPlaceAt(p, row, col) {
  for (const [sr, sc] of p.cells) {
    const nr = row + sr, nc = col + sc;
    if (nc < 0 || nc >= COLS || nr >= ROWS) return false;
    if (nr >= 0 && board[nr][nc] !== 0) return false;
  }
  return true;
}

// ═══ HOLD ═══
function doHold() {
  if (gameState !== 'playing' || gameOver || !currentPiece || holdUsedThisTurn) return;
  holdUsedThisTurn = true;
  if (holdPiece) {
    const saved = holdPiece;
    holdPiece = { cells: getDefaultCells(currentPiece.id), colors: [...currentPiece.colors], id: currentPiece.id };
    currentPiece = { cells: getDefaultCells(saved.id), colors: [...saved.colors], row: 0, col: getDefaultCol(saved.id), id: saved.id };
  } else {
    holdPiece = { cells: getDefaultCells(currentPiece.id), colors: [...currentPiece.colors], id: currentPiece.id };
    currentPiece = nextPiece;
    nextPiece = createPiece();
  }
  if (!canMove(currentPiece, 0, 0)) triggerGameOver();
  dropTimer = 0;
}

// ═══ LOCK → REACTIONS ═══
function lockPiece(piece) {
  // Place cells on board with unique tag to track through gravity
  const TAG_BASE = 100; // temporary tag: TAG_BASE + color
  const placedCols = new Set();
  for (let i = 0; i < piece.cells.length; i++) {
    const r = piece.row + piece.cells[i][0];
    const c = piece.col + piece.cells[i][1];
    if (r < 0) { triggerGameOver(); return; }
    // Tag: 100+color so we can find them after gravity
    board[r][c] = TAG_BASE + piece.colors[i];
    placedCols.add(c);
  }
  
  // Apply gravity (tagged cells move with it)
  applyGravityRaw(); // no active remap version
  
  // Find tagged cells, restore real values, mark active
  activeCells = new Set();
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c] >= TAG_BASE) {
        board[r][c] = board[r][c] - TAG_BASE; // restore real color
        activeCells.add(r + ',' + c);
      }
    }
  }

  turn++;
  holdUsedThisTurn = false;
  document.getElementById('turn').textContent = turn;
  comboCount = 0;
  if (turn % HEAT_INTERVAL === 0) startHeat();
  else { updateHeatBar(); startResolve(); }
}

// ═══ MERGE ═══
function processMerges() {
  if (activeCells.size === 0) return false;
  let merged = false;
  const nextActive = new Set();
  const processed = new Set();

  for (const key of activeCells) {
    if (processed.has(key)) continue;
    const parts2 = key.split(',');
    const r = Number(parts2[0]), c = Number(parts2[1]);
    if (board[r][c] <= 0 || board[r][c] > MAX_LEVEL) continue;
    const level = board[r][c];

    const group = [], visited = new Set(), stack = [{r, c}];
    while (stack.length) {
      const u = stack.pop();
      const k = u.r + ',' + u.c;
      if (u.r < 0 || u.r >= ROWS || u.c < 0 || u.c >= COLS) continue;
      if (visited.has(k) || board[u.r][u.c] !== level) continue;
      visited.add(k);
      group.push(u);
      for (const [dr, dc] of DIRS) stack.push({r: u.r + dr, c: u.c + dc});
    }
    if (group.length < 2) continue;

    for (const g of group) processed.add(g.r + ',' + g.c);
    merged = true;

    group.sort((a, b) => b.r - a.r || a.c - b.c);
    const sv = group[0];
    const newLv = Math.min(level + (group.length - 1), MAX_LEVEL + 1);
    for (const g of group) board[g.r][g.c] = 0;
    board[sv.r][sv.c] = newLv;
    nextActive.add(sv.r + ',' + sv.c);

    // Effects
    const sx = sv.c * CELL + CELL / 2, sy = sv.r * CELL + CELL / 2;
    const rgb = COLOR_RGB[Math.min(newLv, MAX_LEVEL)] || [200,200,200];
    for (let i = 1; i < group.length; i++) {
      const g = group[i], gx = g.c * CELL + CELL / 2, gy = g.r * CELL + CELL / 2;
      const ang = Math.atan2(sy - gy, sx - gx);
      for (let j = 0; j < 6; j++) {
        const a = ang + (Math.random() - 0.5) * 0.8, sp = 1.5 + Math.random() * 2;
        particles.push({x:gx,y:gy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,decay:0.025,size:3+Math.random()*2.5,r:rgb[0],g:rgb[1],b:rgb[2]});
      }
    }
    for (let i = 0; i < 4 + group.length * 2; i++) {
      const a = Math.random() * Math.PI * 2, sp = 0.8 + Math.random() * 1.5;
      particles.push({x:sx,y:sy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-0.5,life:0.7,decay:0.025,size:2+Math.random()*2,r:Math.min(rgb[0]+60,255),g:Math.min(rgb[1]+60,255),b:Math.min(rgb[2]+60,255)});
    }
    if (group.length >= 3) rings.push({x:sx,y:sy,radius:3,maxR:CELL*1.2+group.length*5,life:1,spd:2.5,color:COLORS[Math.min(newLv,MAX_LEVEL)]});

    const pts = group.length * level * 15 * Math.max(comboCount, 1);
    score += pts;
    floatingTexts.push({x:sx,y:sy,text:group.length>=3?group.length+'MERGE +'+pts:'+'+pts,life:1.1,decay:0.02,vy:-1.3,size:group.length>=3?16:12,color:group.length>=3?'#66ffcc':'#fff',scale:1.2});
    cellScale[sv.r+','+sv.c] = 1.3 + group.length * 0.05;
    cellFlash[sv.r+','+sv.c] = {alpha:1.2,type:'white'};
  }

  if (merged) { document.getElementById('score').textContent = score; shakeAmount = Math.max(shakeAmount, 4); activeCells = nextActive; }
  else activeCells = new Set();
  return merged;
}

// ═══ EXPLOSIONS ═══
function processExplosions() {
  const ex = [];
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (board[r][c] > MAX_LEVEL) ex.push({r,c});
  if (!ex.length) return false;

  const chain = comboCount + 1;
  const pts = ex.length * 200 * chain;
  score += pts;
  document.getElementById('score').textContent = score;

  const comboEl = document.getElementById('combo-display');
  if (chain >= 2) {
    comboEl.textContent = chain >= 4 ? '\u{1F4A5} ' + chain + 'x CHAIN!' : chain + 'x CHAIN!';
    comboEl.className = 'active';
    comboEl.style.transform = 'scale(1.3)';
    setTimeout(function(){ comboEl.style.transform = 'scale(1)'; }, 150);
  }

  for (const pos of ex) {
    const px = pos.c * CELL + CELL / 2, py = pos.r * CELL + CELL / 2, rgb = COLOR_RGB[MAX_LEVEL];
    const cnt = 18 + chain * 5;
    for (let i = 0; i < cnt; i++) {
      const a = (Math.PI*2/cnt)*i+(Math.random()-0.5)*0.6, sp = 3+Math.random()*4+chain*0.5;
      particles.push({x:px,y:py,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-2.5,life:1.5,decay:0.01+Math.random()*0.008,size:3.5+Math.random()*5,r:rgb[0],g:rgb[1],b:rgb[2]});
    }
    for (let i = 0; i < 6; i++) {
      const a = Math.random()*Math.PI*2, sp = 1+Math.random()*2;
      particles.push({x:px,y:py,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-1,life:0.8,decay:0.025,size:4+Math.random()*3,r:255,g:255,b:220});
    }
    rings.push({x:px,y:py,radius:5,maxR:CELL*1.8+chain*8,life:1,spd:3+chain,color:COLORS[MAX_LEVEL]});
    floatingTexts.push({x:px+(Math.random()-0.5)*8,y:py,text:'+'+200*chain,life:1.5,decay:0.014,vy:-2.2-chain*0.2,size:chain>=3?24:chain>=2?20:16,color:chain>=3?'#ff2222':chain>=2?'#ffcc00':'#fff',scale:1.5});
    cellFlash[pos.r+','+pos.c] = {alpha:2.5,type:'white'};
  }
  if (chain >= 2) floatingTexts.push({x:BOARD_W/2,y:BOARD_H/2-30,text:(chain>=4?'\u{1F4A5} ':'')+chain+'x CHAIN!',life:2,decay:0.015,vy:-0.4,size:26+chain*4,color:chain>=4?'#ff1111':'#ffaa00',scale:1.8});
  if (chain === 1 && ex.length >= 2) floatingTexts.push({x:BOARD_W/2,y:BOARD_H/2,text:'BOOM!',life:1.2,decay:0.02,vy:-0.5,size:24,color:'#ff6644',scale:1.4});

  hitstopTimer = chain >= 3 ? 120 : chain >= 2 ? 80 : 50;
  shakeAmount = Math.min(8 + chain * 5, 25);
  screenFlash = Math.min(0.35 + chain * 0.12, 0.8);

  for (const pos of ex) board[pos.r][pos.c] = 0;
  const affected = new Set(), junkDead = [];
  for (const pos of ex) for (const [dr, dc] of DIRS) {
    const nr = pos.r+dr, nc = pos.c+dc;
    if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
    if (board[nr][nc] === JUNK) { junkDead.push({r:nr,c:nc}); board[nr][nc] = 0; }
    else if (board[nr][nc] > 0) affected.add(nr+','+nc);
  }
  for (const jd of junkDead) {
    const jx = jd.c*CELL+CELL/2, jy = jd.r*CELL+CELL/2;
    for (let i = 0; i < 6; i++) { const a = (Math.PI*2/6)*i+Math.random()*0.5; particles.push({x:jx,y:jy,vx:Math.cos(a)*2,vy:Math.sin(a)*2-1,life:0.8,decay:0.025,size:3,r:JUNK_RGB[0],g:JUNK_RGB[1],b:JUNK_RGB[2]}); }
  }
  for (const k of affected) {
    const p2 = k.split(','); const ar = Number(p2[0]), ac = Number(p2[1]);
    board[ar][ac]++;
    cellFlash[k] = {alpha:1,type:'warm'};
    cellScale[k] = 1.15;
    activeCells.add(k);
  }
  return true;
}

// ═══ GRAVITY ═══
// Raw gravity — just compact columns, no active cell tracking
function applyGravityRaw() {
  for (let c = 0; c < COLS; c++) {
    let w = ROWS - 1;
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[r][c] !== 0) { if (r !== w) { board[w][c] = board[r][c]; board[r][c] = 0; } w--; }
    }
  }
}

// Gravity with active cell tracking via tagging
// Uses TAG offset (100+val) to mark active cells, same as lockPiece
const GRAV_TAG = 100;
function applyGravity() {
  // Tag active cells before gravity
  for (const key of activeCells) {
    const p2 = key.split(','); const r = Number(p2[0]), c = Number(p2[1]);
    if (board[r][c] !== 0 && board[r][c] !== JUNK) {
      board[r][c] = GRAV_TAG + board[r][c];
    }
  }
  
  // Compact columns
  applyGravityRaw();
  
  // Find tagged cells, restore values, rebuild activeCells
  activeCells = new Set();
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c] >= GRAV_TAG) {
        board[r][c] = board[r][c] - GRAV_TAG;
        activeCells.add(r + ',' + c);
      }
    }
  }
}

// ═══ HEAT ═══
function startHeat() {
  gameState = 'heat'; heatAnimTimer = 0;
  preHeatBoard = board.map(function(r){ return r.slice(); });
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (board[r][c] > 0) board[r][c]++;
  shakeAmount = 5;
}
function updateHeat(dt) {
  heatAnimTimer += dt;
  const t = Math.min(heatAnimTimer / HEAT_DURATION, 1);
  shakeAmount = Math.sin(t * Math.PI) * 5;
  if (t >= 1) {
    preHeatBoard = null; shakeAmount = 0; updateHeatBar();
    activeCells = new Set();
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (board[r][c] > 0) activeCells.add(r+','+c);
    comboCount = 0; startResolve();
  }
}
function updateHeatBar() { document.getElementById('heat-bar-fill').style.width = (turn % HEAT_INTERVAL) / HEAT_INTERVAL * 100 + '%'; }

// ═══ RESOLVE ═══
function startResolve() { gameState = 'resolve'; resolveTimer = 0; }
function updateResolve(dt) { resolveTimer += dt; if (resolveTimer >= RESOLVE_DELAY) doResolveStep(); }
function doResolveStep() {
  if (processMerges()) { applyGravity(); comboCount++; resolveTimer = 0; return; }
  if (processExplosions()) { applyGravity(); comboCount++; resolveTimer = 0; return; }
  updateHeatBar(); finishTurn();
}

// ═══ JUNK ═══
function planNextJunk() {
  pendingJunkCols = [];
  const ne = turn + 1 - JUNK_START;
  if (ne < 0) return;
  const intv = Math.max(3, JUNK_BASE_INT - Math.floor(ne / 20));
  if (ne % intv !== 0) return;
  const cnt = Math.min(2 + Math.floor(ne / 15), 4), used = new Set();
  for (let i = 0; i < cnt; i++) { let c, att = 0; do { c = Math.floor(Math.random()*COLS); att++; } while (used.has(c) && att < 10); used.add(c); pendingJunkCols.push(c); }
}
function spawnJunk(cols) {
  for (const c of cols) {
    let placed = false;
    for (let r = 0; r < ROWS; r++) { if (board[r][c] !== 0) { if (r===0) break; board[r-1][c]=JUNK; cellScale[(r-1)+','+c]=1.4; cellFlash[(r-1)+','+c]={alpha:1,type:'white'}; placed=true; break; } }
    if (!placed && board[ROWS-1][c]===0) { board[ROWS-1][c]=JUNK; cellScale[(ROWS-1)+','+c]=1.4; }
  }
  if (cols.length) { floatingTexts.push({x:BOARD_W/2,y:40,text:'\u26A0 JUNK!',life:1,decay:0.025,vy:-0.3,size:14,color:'#888'}); shakeAmount=2; }
}

function finishTurn() {
  if (warningJunkCols.length) { spawnJunk(warningJunkCols); applyGravityRaw(); }
  warningJunkCols = pendingJunkCols.slice();
  planNextJunk();
  gameState = 'playing'; currentPiece = nextPiece; nextPiece = createPiece();
  if (!canMove(currentPiece, 0, 0)) triggerGameOver();
  dropTimer = 0;
  setTimeout(function(){ var el=document.getElementById('combo-display'); el.textContent=''; el.className=''; }, 600);
}

function hardDrop() { if (gameState!=='playing'||gameOver||!currentPiece) return; while(canMove(currentPiece,1,0)) currentPiece.row++; lockPiece(currentPiece); }
function triggerGameOver() { gameOver=true; document.getElementById('final-score').textContent=score; document.getElementById('game-over-overlay').classList.add('show'); }

// ═══ DRAWING ═══
function drawCell(c, x, y, lv, sz, al) {
  if (sz === undefined) sz = CELL;
  if (al === undefined) al = 1;
  if (lv === 0) return;
  var pd=2, dx=x+pd, dy=y+pd, ds=sz-pd*2, rd=4;
  c.save(); c.globalAlpha *= al;

  if (lv === JUNK) {
    c.fillStyle=JUNK_COLOR; c.beginPath(); c.roundRect(dx,dy,ds,ds,rd); c.fill();
    c.strokeStyle='rgba(0,0,0,0.3)'; c.lineWidth=1;
    for (var i=0;i<ds;i+=6) { c.beginPath(); c.moveTo(dx+i,dy); c.lineTo(dx,dy+i); c.stroke(); c.beginPath(); c.moveTo(dx+ds-i,dy+ds); c.lineTo(dx+ds,dy+ds-i); c.stroke(); }
    var g=c.createLinearGradient(dx,dy,dx,dy+ds); g.addColorStop(0,'rgba(255,255,255,0.08)'); g.addColorStop(1,'rgba(0,0,0,0.15)'); c.fillStyle=g; c.beginPath(); c.roundRect(dx,dy,ds,ds,rd); c.fill();
    c.fillStyle='rgba(255,255,255,'+0.3*al+')'; c.font='bold '+Math.floor(sz*0.35)+'px Outfit'; c.textAlign='center'; c.textBaseline='middle'; c.fillText('\u2715',x+sz/2,y+sz/2);
    c.restore(); return;
  }

  // FIX #4: clamp display level
  var v = Math.min(lv, MAX_LEVEL);
  if (v>=4) { c.shadowColor=COLORS[v]; c.shadowBlur=v===5?16:8; }
  c.fillStyle=COLORS[v]; c.beginPath(); c.roundRect(dx,dy,ds,ds,rd); c.fill();
  var g2=c.createLinearGradient(dx,dy,dx,dy+ds); g2.addColorStop(0,'rgba(255,255,255,0.25)'); g2.addColorStop(0.5,'rgba(255,255,255,0)'); g2.addColorStop(1,'rgba(0,0,0,0.2)'); c.fillStyle=g2; c.beginPath(); c.roundRect(dx,dy,ds,ds,rd); c.fill();
  c.shadowColor='transparent'; c.shadowBlur=0;
  c.fillStyle='rgba(255,255,255,'+0.55*al+')'; c.font='bold '+Math.floor(sz*0.35)+'px Outfit'; c.textAlign='center'; c.textBaseline='middle'; c.fillText(v,x+sz/2,y+sz/2);
  c.restore();
}

function draw() {
  var sx=0, sy=0;
  if (shakeAmount>0.2) { sx=(Math.random()-0.5)*shakeAmount; sy=(Math.random()-0.5)*shakeAmount; shakeAmount*=0.87; if(shakeAmount<0.2)shakeAmount=0; }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(PAD+sx,PAD+sy);
  if (screenFlash>0.01) { ctx.save(); ctx.translate(-PAD,-PAD); ctx.fillStyle='rgba(255,220,100,'+screenFlash+')'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); screenFlash*=0.88; if(screenFlash<0.01)screenFlash=0; }
  ctx.fillStyle='#0d0d18'; ctx.fillRect(0,0,BOARD_W,BOARD_H);

  // Grid
  ctx.strokeStyle='#151525'; ctx.lineWidth=1;
  for (var r=0;r<=ROWS;r++) { ctx.beginPath(); ctx.moveTo(0,r*CELL); ctx.lineTo(BOARD_W,r*CELL); ctx.stroke(); }
  for (var c=0;c<=COLS;c++) { ctx.beginPath(); ctx.moveTo(c*CELL,0); ctx.lineTo(c*CELL,BOARD_H); ctx.stroke(); }

  // Junk warnings
  for (var wi=0;wi<warningJunkCols.length;wi++) {
    var col=warningJunkCols[wi];
    ctx.fillStyle='rgba(255,60,60,0.06)'; ctx.fillRect(col*CELL,0,CELL,BOARD_H);
    var pulse=0.5+Math.sin(Date.now()*0.006)*0.3;
    ctx.fillStyle='rgba(255,80,60,'+pulse+')'; ctx.font='bold 16px Outfit'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('\u26A0',col*CELL+CELL/2,12);
    var eg=ctx.createLinearGradient(col*CELL,0,col*CELL,CELL); eg.addColorStop(0,'rgba(255,60,40,'+pulse*0.3+')'); eg.addColorStop(1,'rgba(255,60,40,0)'); ctx.fillStyle=eg; ctx.fillRect(col*CELL,0,CELL,CELL);
  }

  // Board cells
  if (gameState==='heat' && preHeatBoard) {
    var t=Math.min(heatAnimTimer/HEAT_DURATION,1), wY=t*(BOARD_H+60)-30;
    for (var r=0;r<ROWS;r++) for (var c=0;c<COLS;c++) {
      var ol=preHeatBoard[r][c];
      if (ol===JUNK) drawCell(ctx,c*CELL,r*CELL,JUNK);
      else if (ol>0) { var nl=board[r][c],cY=r*CELL+CELL/2,ct=Math.max(0,Math.min(1,(wY-cY+40)/80)); drawCell(ctx,c*CELL,r*CELL,ol,CELL,1-ct); drawCell(ctx,c*CELL,r*CELL,nl,CELL,ct); }
    }
    var hg=ctx.createLinearGradient(0,wY-40,0,wY+40); hg.addColorStop(0,'rgba(255,80,30,0)'); hg.addColorStop(0.5,'rgba(255,80,30,'+0.2*Math.sin(t*Math.PI)+')'); hg.addColorStop(1,'rgba(255,80,30,0)'); ctx.fillStyle=hg; ctx.fillRect(0,wY-40,BOARD_W,80);
    var pu=Math.sin(t*Math.PI)*0.08; if(pu>0){ctx.fillStyle='rgba(231,76,60,'+pu+')';ctx.fillRect(0,0,BOARD_W,BOARD_H);}
  } else {
    for (var r=0;r<ROWS;r++) for (var c=0;c<COLS;c++) {
      if (board[r][c]===0) continue;
      var k=r+','+c; var sc=cellScale[k]||1;
      if (sc>1){sc-=0.04;if(sc<=1){sc=1;delete cellScale[k];}else cellScale[k]=sc;}
      var px=c*CELL+CELL/2,py=r*CELL+CELL/2;
      ctx.save();ctx.translate(px,py);ctx.scale(sc,sc);ctx.translate(-px,-py);
      drawCell(ctx,c*CELL,r*CELL,board[r][c]===JUNK?JUNK:board[r][c]);ctx.restore();
      var fl=cellFlash[k];if(fl&&fl.alpha>0){ctx.save();ctx.globalAlpha=Math.min(fl.alpha,1)*0.6;ctx.fillStyle=fl.type==='white'?'#fff':'#ff6633';ctx.beginPath();ctx.roundRect(c*CELL+2,r*CELL+2,CELL-4,CELL-4,4);ctx.fill();ctx.restore();fl.alpha-=0.05;if(fl.alpha<=0)delete cellFlash[k];}
    }
  }

  // Ghost + current
  if (currentPiece && gameState==='playing' && !gameOver) {
    var gr=currentPiece.row; while(canPlaceAt(currentPiece,gr+1,currentPiece.col))gr++;
    if (gr!==currentPiece.row) for (var i=0;i<currentPiece.cells.length;i++){var r2=gr+currentPiece.cells[i][0],c2=currentPiece.col+currentPiece.cells[i][1];drawCell(ctx,c2*CELL,r2*CELL,currentPiece.colors[i],CELL,0.18);}
    for (var i=0;i<currentPiece.cells.length;i++){var r2=currentPiece.row+currentPiece.cells[i][0],c2=currentPiece.col+currentPiece.cells[i][1];if(r2>=0)drawCell(ctx,c2*CELL,r2*CELL,currentPiece.colors[i]);}
  }

  // Particles
  for (var i=particles.length-1;i>=0;i--){var p=particles[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.08;p.life-=p.decay;if(p.life<=0){particles.splice(i,1);continue;}ctx.save();ctx.globalAlpha=Math.min(p.life,1);ctx.fillStyle='rgb('+p.r+','+p.g+','+p.b+')';ctx.shadowColor='rgba('+p.r+','+p.g+','+p.b+',0.8)';ctx.shadowBlur=8;ctx.beginPath();ctx.arc(p.x,p.y,p.size*Math.min(p.life,1),0,Math.PI*2);ctx.fill();ctx.restore();}

  // Rings
  for (var i=rings.length-1;i>=0;i--){var ri=rings[i];ri.radius+=ri.spd;ri.life-=0.03;if(ri.life<=0||ri.radius>ri.maxR){rings.splice(i,1);continue;}ctx.save();ctx.globalAlpha=ri.life*0.7;ctx.strokeStyle=ri.color;ctx.lineWidth=3*ri.life;ctx.shadowColor=ri.color;ctx.shadowBlur=12;ctx.beginPath();ctx.arc(ri.x,ri.y,ri.radius,0,Math.PI*2);ctx.stroke();ctx.restore();}

  // Float texts
  for (var i=floatingTexts.length-1;i>=0;i--){var f=floatingTexts[i];f.y+=f.vy;f.vy*=0.97;f.life-=f.decay;if(f.scale)f.scale=Math.max(1,f.scale-0.03);if(f.life<=0){floatingTexts.splice(i,1);continue;}ctx.save();ctx.globalAlpha=Math.min(f.life,1);var s=f.scale||1;ctx.translate(f.x,f.y);ctx.scale(s,s);ctx.fillStyle=f.color;ctx.font='900 '+f.size+'px Outfit';ctx.textAlign='center';ctx.textBaseline='middle';ctx.shadowColor='rgba(0,0,0,0.7)';ctx.shadowBlur=6;ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=3;ctx.strokeText(f.text,0,0);ctx.fillText(f.text,0,0);ctx.restore();}

  ctx.restore();
}

function drawSide(context,piece,w,h) {
  context.clearRect(0,0,w,h); if(!piece) return;
  var cs=16,cells=piece.cells;
  var mc=0,mr=0;for(var i=0;i<cells.length;i++){if(cells[i][1]>mc)mc=cells[i][1];if(cells[i][0]>mr)mr=cells[i][0];}mc++;mr++;
  var ox=(w-mc*cs)/2,oy=(h-mr*cs)/2;
  for(var i=0;i<cells.length;i++) drawCell(context,ox+cells[i][1]*cs,oy+cells[i][0]*cs,piece.colors[i],cs);
}

// ═══ LOOP ═══
function gameLoop(ts) {
  if (!lastFrameTime) lastFrameTime = ts;
  var dt = ts - lastFrameTime; lastFrameTime = ts;
  if (!gameOver) {
    if (hitstopTimer > 0) hitstopTimer -= dt;
    else switch (gameState) {
      case 'playing': dropTimer+=dt; if(dropTimer>=dropInterval){dropTimer=0;if(currentPiece&&canMove(currentPiece,1,0))currentPiece.row++;else if(currentPiece)lockPiece(currentPiece);} break;
      case 'heat': updateHeat(dt); break;
      case 'resolve': updateResolve(dt); break;
    }
  }
  draw(); drawSide(nextCtx,nextPiece,60,60); drawSide(holdCtx,holdPiece,60,60);
  requestAnimationFrame(gameLoop);
}

// ═══ INPUT ═══
document.addEventListener('keydown', function(e) {
  if (gameOver||gameState!=='playing'||!currentPiece) return;
  switch(e.key) {
    case 'ArrowLeft': if(canMove(currentPiece,0,-1))currentPiece.col--; break;
    case 'ArrowRight': if(canMove(currentPiece,0,1))currentPiece.col++; break;
    case 'ArrowDown': if(canMove(currentPiece,1,0)){currentPiece.row++;dropTimer=0;} break;
    case 'ArrowUp': case 'x': case 'X': rotateCW(currentPiece); break;
    case 'z': case 'Z': rotateCCW(currentPiece); break;
    case ' ': e.preventDefault(); hardDrop(); break;
    case 'c': case 'C': doHold(); break;
  }
});

document.querySelectorAll('.touch-btn').forEach(function(b) {
  b.addEventListener('touchstart', function(e) {
    e.preventDefault(); if(gameOver||gameState!=='playing'||!currentPiece)return;
    switch(b.dataset.action) {
      case 'left': if(canMove(currentPiece,0,-1))currentPiece.col--; break;
      case 'right': if(canMove(currentPiece,0,1))currentPiece.col++; break;
      case 'down': if(canMove(currentPiece,1,0)){currentPiece.row++;dropTimer=0;} break;
      case 'rotR': rotateCW(currentPiece); break;
      case 'rotL': rotateCCW(currentPiece); break;
      case 'drop': hardDrop(); break;
      case 'hold': doHold(); break;
    }
  });
});

document.getElementById('restart-btn').addEventListener('click', startGame);

// ═══ START ═══
function startGame() {
  initBoard(); score=0; turn=0; gameOver=false; gameState='playing';
  dropTimer=0; comboCount=0; hitstopTimer=0;
  holdPiece=null; holdUsedThisTurn=false;
  particles=[]; floatingTexts=[]; rings=[];
  cellFlash={}; cellScale={}; activeCells=new Set();
  shakeAmount=0; screenFlash=0; preHeatBoard=null;
  pendingJunkCols=[]; warningJunkCols=[];
  document.getElementById('score').textContent='0';
  document.getElementById('turn').textContent='0';
  document.getElementById('combo-display').textContent='';
  document.getElementById('combo-display').className='';
  document.getElementById('heat-bar-fill').style.width='0%';
  document.getElementById('game-over-overlay').classList.remove('show');
  currentPiece=createPiece(); nextPiece=createPiece();
  planNextJunk(); lastFrameTime=0;
}
startGame(); requestAnimationFrame(gameLoop);
</script>
</body>
</html>
